#!/bin/bash

################################################################################
# Professional Web Penetration Testing Framework - Advanced Installer
# Vers√£o: 3.0 - ENHANCED
# Criado por: BUCH CTF Team
# 
# MELHORIAS V3.0:
# - Instala√ß√£o paralela (mais r√°pido)
# - Auto-fix de problemas comuns
# - Docker support
# - Backup e rollback
# - Health check cont√≠nuo
# - Performance otimizada
# - Logging detalhado
# - Menu interativo
################################################################################

set -e
set -o pipefail

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Vari√°veis Globais
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
FRAMEWORK_DIR="$SCRIPT_DIR"
VENV_DIR="$FRAMEWORK_DIR/venv"
TOOLS_DIR="$FRAMEWORK_DIR/tools"
OUTPUT_DIR="$FRAMEWORK_DIR/output"
BACKUP_DIR="$FRAMEWORK_DIR/.backups"
LOG_DIR="$FRAMEWORK_DIR/logs"
LOG_FILE="$LOG_DIR/install_$(date +%Y%m%d_%H%M%S).log"
GO_VERSION="1.21.5"
GO_BIN="$HOME/go/bin"
PYTHON_MIN_VERSION="3.7"
PARALLEL_JOBS=4
INSTALL_FAILED=0

# Criar diret√≥rios necess√°rios
mkdir -p "$BACKUP_DIR" "$LOG_DIR" "$TOOLS_DIR" "$OUTPUT_DIR"

# Fun√ß√£o de logging
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

log_error() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $1" | tee -a "$LOG_FILE" >&2
}

# Fun√ß√µes de output melhoradas
print_banner() {
    clear
    echo -e "${GREEN}"
    cat << "EOF"
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                                            ‚ïë
‚ïë     üîí Professional Web Penetration Testing Framework v3.0 üîí            ‚ïë
‚ïë                                                                            ‚ïë
‚ïë                    Advanced Installer & Orchestrator                      ‚ïë
‚ïë                    Created by BUCH CTF Team                                ‚ïë
‚ïë                                                                            ‚ïë
‚ïë  NEW in v3.0:                                                             ‚ïë
‚ïë  ‚ú® Instala√ß√£o Paralela    ‚ö° 3x Mais R√°pido                            ‚ïë
‚ïë  üîß Auto-Fix de Problemas  üíæ Backup Autom√°tico                          ‚ïë
‚ïë  üê≥ Docker Support         üìä Health Check                               ‚ïë
‚ïë  üéØ Menu Interativo        üìù Logging Detalhado                          ‚ïë
‚ïë                                                                            ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
EOF
    echo -e "${NC}"
}

print_section() {
    echo -e "\n${CYAN}${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${CYAN}${BOLD}  $1${NC}"
    echo -e "${CYAN}${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}\n"
}

print_step() {
    echo -e "${BLUE}[*]${NC} $1"
    log "STEP: $1"
}

print_success() {
    echo -e "${GREEN}[‚úì]${NC} $1"
    log "SUCCESS: $1"
}

print_error() {
    echo -e "${RED}[‚úó]${NC} $1"
    log_error "$1"
    INSTALL_FAILED=1
}

print_warning() {
    echo -e "${YELLOW}[‚ö†]${NC} $1"
    log "WARNING: $1"
}

print_info() {
    echo -e "${CYAN}[‚Ñπ]${NC} $1"
    log "INFO: $1"
}

print_progress() {
    local current=$1
    local total=$2
    local percent=$((current * 100 / total))
    local bar_length=50
    local filled=$((bar_length * current / total))
    
    printf "\r${CYAN}["
    printf "%${filled}s" | tr ' ' '‚ñà'
    printf "%$((bar_length - filled))s" | tr ' ' '‚ñë'
    printf "] %d%% (%d/%d)${NC}" $percent $current $total
    
    if [ $current -eq $total ]; then
        echo ""
    fi
}

# Verifica√ß√µes de seguran√ßa e sistema
check_root() {
    if [ "$EUID" -eq 0 ]; then 
        print_error "N√£o execute este script como root!"
        print_info "Execute como usu√°rio normal. O script pedir√° senha quando necess√°rio."
        exit 1
    fi
}

check_disk_space() {
    print_step "Verificando espa√ßo em disco..."
    local required_space=2048000 # 2GB em KB
    local available_space=$(df "$FRAMEWORK_DIR" | awk 'NR==2 {print $4}')
    
    if [ "$available_space" -lt "$required_space" ]; then
        print_error "Espa√ßo insuficiente em disco. Necess√°rio: 2GB, Dispon√≠vel: $((available_space / 1024))MB"
        return 1
    fi
    
    print_success "Espa√ßo em disco OK: $((available_space / 1024 / 1024))GB dispon√≠vel"
}

check_internet() {
    print_step "Verificando conex√£o com internet..."
    
    if ping -c 1 8.8.8.8 &> /dev/null || ping -c 1 1.1.1.1 &> /dev/null; then
        print_success "Conex√£o com internet OK"
        return 0
    else
        print_error "Sem conex√£o com internet"
        return 1
    fi
}

check_python_version() {
    print_step "Verificando vers√£o do Python..."
    
    if ! command -v python3 &> /dev/null; then
        print_error "Python 3 n√£o encontrado"
        return 1
    fi
    
    local python_version=$(python3 -c 'import sys; print(".".join(map(str, sys.version_info[:2])))')
    local required_version=$PYTHON_MIN_VERSION
    
    if [ "$(printf '%s\n' "$required_version" "$python_version" | sort -V | head -n1)" = "$required_version" ]; then
        print_success "Python $python_version (OK)"
        return 0
    else
        print_error "Python $python_version √© muito antigo. M√≠nimo requerido: $required_version"
        return 1
    fi
}

check_os() {
    print_step "Verificando sistema operacional..."
    
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        OS=$ID
        VER=$VERSION_ID
        print_success "Sistema: $OS $VER"
        
        case $OS in
            kali|debian|ubuntu)
                export PACKAGE_MANAGER="apt"
                ;;
            arch|manjaro)
                export PACKAGE_MANAGER="pacman"
                print_warning "Arch Linux detectado. Algumas funcionalidades podem variar."
                ;;
            fedora|centos|rhel)
                export PACKAGE_MANAGER="dnf"
                print_warning "Fedora/RHEL detectado. Algumas funcionalidades podem variar."
                ;;
            *)
                print_warning "Sistema n√£o identificado. Tentando usar apt..."
                export PACKAGE_MANAGER="apt"
                ;;
        esac
        return 0
    else
        print_error "N√£o foi poss√≠vel detectar o sistema operacional"
        return 1
    fi
}

# Backup e rollback
create_backup() {
    print_step "Criando backup..."
    local backup_name="backup_$(date +%Y%m%d_%H%M%S).tar.gz"
    local backup_path="$BACKUP_DIR/$backup_name"
    
    # Backup de arquivos importantes
    tar -czf "$backup_path" \
        --exclude='venv' \
        --exclude='tools' \
        --exclude='output' \
        --exclude='*.pyc' \
        --exclude='__pycache__' \
        "$FRAMEWORK_DIR"/*.py \
        "$FRAMEWORK_DIR"/core \
        "$FRAMEWORK_DIR"/modules \
        2>/dev/null || true
    
    if [ -f "$backup_path" ]; then
        print_success "Backup criado: $backup_name"
        echo "$backup_path" > "$BACKUP_DIR/last_backup.txt"
        
        # Manter apenas os √∫ltimos 5 backups
        ls -t "$BACKUP_DIR"/backup_*.tar.gz | tail -n +6 | xargs rm -f 2>/dev/null || true
    else
        print_warning "Falha ao criar backup (n√£o cr√≠tico)"
    fi
}

rollback() {
    if [ ! -f "$BACKUP_DIR/last_backup.txt" ]; then
        print_error "Nenhum backup encontrado para rollback"
        return 1
    fi
    
    local last_backup=$(cat "$BACKUP_DIR/last_backup.txt")
    
    if [ ! -f "$last_backup" ]; then
        print_error "Arquivo de backup n√£o encontrado: $last_backup"
        return 1
    fi
    
    print_step "Executando rollback..."
    tar -xzf "$last_backup" -C /tmp/
    # Copiar arquivos de volta
    cp -r /tmp/pentest-framework/* "$FRAMEWORK_DIR/" 2>/dev/null || true
    print_success "Rollback conclu√≠do"
}

# Instala√ß√£o otimizada do sistema
update_system() {
    print_section "Atualizando Sistema"
    
    case $PACKAGE_MANAGER in
        apt)
            print_step "Atualizando cache do apt..."
            sudo apt update -qq 2>&1 | tee -a "$LOG_FILE" || {
                print_warning "Erro ao atualizar apt. Tentando consertar..."
                sudo apt --fix-broken install -y
                sudo dpkg --configure -a
                sudo apt update -qq
            }
            
            print_step "Instalando depend√™ncias base..."
            sudo apt install -y -qq \
                curl wget git build-essential \
                python3 python3-pip python3-venv \
                software-properties-common apt-transport-https \
                ca-certificates gnupg lsb-release \
                libssl-dev libffi-dev \
                jq parallel \
                2>&1 | tee -a "$LOG_FILE"
            ;;
        pacman)
            sudo pacman -Sy --noconfirm \
                base-devel python python-pip git curl wget \
                2>&1 | tee -a "$LOG_FILE"
            ;;
        dnf)
            sudo dnf install -y \
                @development-tools python3 python3-pip git curl wget \
                2>&1 | tee -a "$LOG_FILE"
            ;;
    esac
    
    print_success "Sistema atualizado"
}

# Instala√ß√£o do Go com verifica√ß√£o de vers√£o
install_go() {
    print_section "Instalando Go"
    
    if command -v go &> /dev/null; then
        local GO_VER=$(go version | awk '{print $3}' | sed 's/go//')
        
        if [ "$(printf '%s\n' "$GO_VERSION" "$GO_VER" | sort -V | head -n1)" = "$GO_VERSION" ]; then
            print_success "Go j√° instalado: $GO_VER (OK)"
            return 0
        else
            print_warning "Go $GO_VER desatualizado. Atualizando para $GO_VERSION..."
        fi
    fi
    
    print_step "Baixando Go $GO_VERSION..."
    cd /tmp
    local GO_TAR="go${GO_VERSION}.linux-amd64.tar.gz"
    
    # Download com retry
    local max_attempts=3
    local attempt=1
    while [ $attempt -le $max_attempts ]; do
        if wget -q --show-progress --progress=bar:force:noscroll "https://go.dev/dl/$GO_TAR" 2>&1; then
            break
        fi
        print_warning "Tentativa $attempt de $max_attempts falhou. Tentando novamente..."
        ((attempt++))
        sleep 2
    done
    
    if [ ! -f "$GO_TAR" ]; then
        print_error "Falha ao baixar Go"
        return 1
    fi
    
    print_step "Instalando Go..."
    sudo rm -rf /usr/local/go
    sudo tar -C /usr/local -xzf "$GO_TAR"
    
    # Configurar PATH de forma mais robusta
    for rc_file in ~/.bashrc ~/.zshrc ~/.profile; do
        if [ -f "$rc_file" ] && ! grep -q '/usr/local/go/bin' "$rc_file"; then
            echo '' >> "$rc_file"
            echo '# Go paths (added by pentest framework)' >> "$rc_file"
            echo 'export PATH=$PATH:/usr/local/go/bin:$HOME/go/bin' >> "$rc_file"
        fi
    done
    
    export PATH=$PATH:/usr/local/go/bin:$HOME/go/bin
    
    print_success "Go $GO_VERSION instalado"
    rm -f "$GO_TAR"
    cd "$FRAMEWORK_DIR"
}

# Instala√ß√£o paralela de ferramentas APT
install_apt_tools_parallel() {
    print_section "Instalando Ferramentas via APT (Paralelo)"
    
    local APT_TOOLS=(
        "nmap" "masscan" "nikto" "sqlmap" 
        "hydra" "whatweb" "gobuster"
        "dirb" "wfuzz" "zaproxy"
    )
    
    local total=${#APT_TOOLS[@]}
    local current=0
    
    # Fun√ß√£o para instalar uma ferramenta
    install_apt_tool() {
        local tool=$1
        if command -v "$tool" &> /dev/null; then
            echo "‚úì $tool"
        else
            if sudo apt install -y -qq "$tool" &> /dev/null; then
                echo "‚úì $tool (instalado)"
            else
                echo "‚úó $tool (falha)"
            fi
        fi
    }
    
    export -f install_apt_tool
    
    # Instalar em paralelo usando GNU Parallel
    if command -v parallel &> /dev/null; then
        printf '%s\n' "${APT_TOOLS[@]}" | parallel -j "$PARALLEL_JOBS" install_apt_tool
    else
        # Fallback: instalar sequencialmente
        for tool in "${APT_TOOLS[@]}"; do
            ((current++))
            print_progress $current $total
            install_apt_tool "$tool"
        done
    fi
    
    print_success "Ferramentas APT instaladas"
}

# Instala√ß√£o otimizada de ferramentas Go
install_go_tools_optimized() {
    print_section "Instalando Ferramentas Go (Otimizado)"
    
    export PATH=$PATH:/usr/local/go/bin:$HOME/go/bin
    export GOPATH=$HOME/go
    
    local GO_TOOLS=(
        "github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest:nuclei"
        "github.com/projectdiscovery/httpx/cmd/httpx@latest:httpx"
        "github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest:subfinder"
        "github.com/projectdiscovery/katana/cmd/katana@latest:katana"
        "github.com/tomnomnom/waybackurls@latest:waybackurls"
        "github.com/lc/gau/v2/cmd/gau@latest:gau"
        "github.com/hahwul/dalfox/v2@latest:dalfox"
        "github.com/tomnomnom/assetfinder@latest:assetfinder"
        "github.com/ffuf/ffuf@latest:ffuf"
        "github.com/projectdiscovery/naabu/v2/cmd/naabu@latest:naabu"
        "github.com/projectdiscovery/dnsx/cmd/dnsx@latest:dnsx"
        "github.com/tomnomnom/anew@latest:anew"
    )
    
    local total=${#GO_TOOLS[@]}
    local current=0
    local failed_tools=()
    
    for tool_info in "${GO_TOOLS[@]}"; do
        IFS=':' read -r tool_path tool_name <<< "$tool_info"
        ((current++))
        
        print_progress $current $total
        
        if command -v "$tool_name" &> /dev/null; then
            continue
        fi
        
        # Instalar com timeout
        if timeout 300 go install -v "$tool_path" &>> "$LOG_FILE"; then
            # Copiar para /usr/local/bin se poss√≠vel
            if [ -f "$GO_BIN/$tool_name" ]; then
                sudo cp "$GO_BIN/$tool_name" /usr/local/bin/ 2>/dev/null || true
            fi
        else
            failed_tools+=("$tool_name")
        fi
    done
    
    echo ""
    
    if [ ${#failed_tools[@]} -eq 0 ]; then
        print_success "Todas as ferramentas Go instaladas"
    else
        print_warning "Algumas ferramentas falharam: ${failed_tools[*]}"
    fi
    
    # Atualizar Nuclei templates
    if command -v nuclei &> /dev/null; then
        print_step "Atualizando templates do Nuclei..."
        nuclei -update-templates -silent &>> "$LOG_FILE" || true
        print_success "Templates do Nuclei atualizados"
    fi
}

# Instala√ß√£o Python com verifica√ß√£o de depend√™ncias
install_python_tools_enhanced() {
    print_section "Instalando Ferramentas Python"
    
    local     PYTHON_TOOLS=(
        "arjun"
        "uro"
        "httpx"
        "wfuzz"
    )
    
    for tool in "${PYTHON_TOOLS[@]}"; do
        if command -v "$tool" &> /dev/null || python3 -m pip show "$tool" &> /dev/null; then
            print_success "$tool j√° instalado"
        else
            print_step "Instalando $tool..."
            if pip3 install -q "$tool" --user &>> "$LOG_FILE"; then
                print_success "$tool instalado"
                
                # Configurar PATH para arjun se necess√°rio
                if [ "$tool" = "arjun" ]; then
                    local arjun_path="$HOME/.local/bin"
                    if [ -f "$arjun_path/arjun" ]; then
                        export PATH="$PATH:$arjun_path"
                        print_info "Arjun dispon√≠vel em: $arjun_path/arjun"
                    fi
                fi
            else
                print_warning "$tool falhou (n√£o cr√≠tico)"
            fi
        fi
    done
    
    # Verificar se arjun est√° realmente funcional
    if command -v arjun &> /dev/null; then
        print_step "Testando Arjun..."
        if timeout 5 arjun --help &> /dev/null; then
            print_success "Arjun funcional"
        else
            print_warning "Arjun instalado mas pode ter problemas"
        fi
    fi
}

# Instala√ß√£o/atualiza√ß√£o do SecLists
install_seclists_enhanced() {
    print_section "Instalando SecLists"
    
    local seclists_path="/usr/share/seclists"
    
    if [ -d "$seclists_path" ]; then
        print_step "SecLists encontrado. Verificando atualiza√ß√µes..."
        if [ -d "$seclists_path/.git" ]; then
            (cd "$seclists_path" && sudo git pull -q) &>> "$LOG_FILE" || true
            print_success "SecLists atualizado"
        else
            print_success "SecLists j√° instalado"
        fi
        return 0
    fi
    
    print_step "Instalando SecLists..."
    
    # Tentar via apt primeiro
    if sudo apt install -y -qq seclists &>> "$LOG_FILE"; then
        print_success "SecLists instalado via apt"
    else
        print_step "Clonando SecLists do GitHub..."
        if sudo git clone --depth 1 https://github.com/danielmiessler/SecLists.git "$seclists_path" &>> "$LOG_FILE"; then
            print_success "SecLists clonado"
        else
            print_error "Falha ao instalar SecLists"
            return 1
        fi
    fi
}

# Clone de reposit√≥rios com verifica√ß√£o
clone_git_repos_enhanced() {
    print_section "Clonando Reposit√≥rios Git"
    
    mkdir -p "$TOOLS_DIR"
    
    local GIT_REPOS=(
        "https://github.com/maurosoria/dirsearch.git:dirsearch"
        "https://github.com/commixproject/commix.git:commix"
        "https://github.com/ticarpi/jwt_tool.git:jwt_tool"
        "https://github.com/sqlmapproject/sqlmap.git:sqlmap"
        "https://github.com/xmendez/wfuzz.git:wfuzz"
    )
    
    for repo_info in "${GIT_REPOS[@]}"; do
        IFS=':' read -r repo name <<< "$repo_info"
        local repo_path="$TOOLS_DIR/$name"
        
        if [ -d "$repo_path" ]; then
            print_step "Atualizando $name..."
            (cd "$repo_path" && git pull -q) &>> "$LOG_FILE" || true
            print_success "$name atualizado"
        else
            print_step "Clonando $name..."
            if git clone --depth 1 "$repo" "$repo_path" &>> "$LOG_FILE"; then
                print_success "$name clonado"
                
                # Instalar requirements se existir
                if [ -f "$repo_path/requirements.txt" ]; then
                    print_step "Instalando requirements para $name..."
                    pip3 install -q -r "$repo_path/requirements.txt" --user &>> "$LOG_FILE" || true
                fi
            else
                print_warning "$name falhou (n√£o cr√≠tico)"
            fi
        fi
    done
}

# Setup do ambiente Python com otimiza√ß√µes
setup_venv_optimized() {
    print_section "Configurando Ambiente Virtual Python"
    
    if [ -d "$VENV_DIR" ]; then
        print_step "Ambiente virtual encontrado. Verificando integridade..."
        if [ -f "$VENV_DIR/bin/activate" ]; then
            print_success "Ambiente virtual OK"
            source "$VENV_DIR/bin/activate"
        else
            print_warning "Ambiente virtual corrompido. Recriando..."
            rm -rf "$VENV_DIR"
            python3 -m venv "$VENV_DIR"
            source "$VENV_DIR/bin/activate"
        fi
    else
        print_step "Criando ambiente virtual..."
        python3 -m venv "$VENV_DIR"
        source "$VENV_DIR/bin/activate"
        print_success "Ambiente virtual criado"
    fi
    
    print_step "Atualizando pip, setuptools e wheel..."
    pip install --upgrade pip setuptools wheel -q &>> "$LOG_FILE"
    
    if [ -f "$FRAMEWORK_DIR/requirements.txt" ]; then
        print_step "Instalando depend√™ncias Python..."
        local req_count=$(wc -l < "$FRAMEWORK_DIR/requirements.txt")
        
        if pip install -r "$FRAMEWORK_DIR/requirements.txt" -q &>> "$LOG_FILE"; then
            print_success "$req_count depend√™ncias instaladas"
        else
            print_warning "Algumas depend√™ncias falharam. Tentando instala√ß√£o individual..."
            while IFS= read -r package; do
                [ -z "$package" ] || [ "${package:0:1}" = "#" ] && continue
                pip install "$package" -q &>> "$LOG_FILE" || print_warning "Falha: $package"
            done < "$FRAMEWORK_DIR/requirements.txt"
        fi
    fi
}

# Health check completo
health_check() {
    print_section "Health Check Completo"
    
    local checks_passed=0
    local checks_total=0
    local critical_failed=()
    
    # Verificar ferramentas essenciais
    local ESSENTIAL_TOOLS=("nuclei" "httpx" "subfinder" "nmap" "python3" "arjun")
    
    echo -e "${BOLD}Ferramentas Essenciais:${NC}"
    for tool in "${ESSENTIAL_TOOLS[@]}"; do
        ((checks_total++))
        if command -v "$tool" &> /dev/null; then
            local version=$(timeout 2 "$tool" --version 2>&1 | head -1 || echo "unknown")
            printf "  ${GREEN}‚úì${NC} %-15s %s\n" "$tool" "$version"
            ((checks_passed++))
        else
            printf "  ${RED}‚úó${NC} %-15s %s\n" "$tool" "NOT FOUND"
            critical_failed+=("$tool")
        fi
    done
    
    # Verificar ferramentas opcionais
    echo -e "\n${BOLD}Ferramentas Opcionais:${NC}"
    local OPTIONAL_TOOLS=("katana" "waybackurls" "gau" "dalfox" "ffuf" "sqlmap" "whatweb")
    
    for tool in "${OPTIONAL_TOOLS[@]}"; do
        ((checks_total++))
        if command -v "$tool" &> /dev/null; then
            printf "  ${GREEN}‚úì${NC} %-15s\n" "$tool"
            ((checks_passed++))
        else
            printf "  ${YELLOW}‚óã${NC} %-15s %s\n" "$tool" "(optional)"
        fi
    done
    
    # Verificar ambiente Python
    echo -e "\n${BOLD}Ambiente Python:${NC}"
    ((checks_total++))
    if [ -f "$VENV_DIR/bin/activate" ]; then
        source "$VENV_DIR/bin/activate"
        printf "  ${GREEN}‚úì${NC} Virtual Environment\n"
        ((checks_passed++))
        
        # Verificar imports Python
        local PYTHON_MODULES=("requests" "yaml" "tqdm" "colorama" "jinja2")
        for module in "${PYTHON_MODULES[@]}"; do
            ((checks_total++))
            if python3 -c "import $module" &> /dev/null; then
                printf "  ${GREEN}‚úì${NC} Python: %-15s\n" "$module"
                ((checks_passed++))
            else
                printf "  ${RED}‚úó${NC} Python: %-15s\n" "$module"
            fi
        done
    else
        printf "  ${RED}‚úó${NC} Virtual Environment\n"
    fi
    
    # Verificar SecLists
    echo -e "\n${BOLD}Wordlists:${NC}"
    ((checks_total++))
    if [ -d "/usr/share/seclists" ]; then
        printf "  ${GREEN}‚úì${NC} SecLists\n"
        ((checks_passed++))
        
        # Verificar wordlists espec√≠ficas importantes
        local CRITICAL_WORDLISTS=(
            "Fuzzing/SQLi/Generic-SQLi.txt"
            "Fuzzing/XSS/XSS-Jhaddix.txt"
            "Discovery/Web-Content/common.txt"
            "Discovery/Web-Content/raft-medium-directories.txt"
        )
        
        for wl in "${CRITICAL_WORDLISTS[@]}"; do
            if [ -f "/usr/share/seclists/$wl" ]; then
                printf "    ${GREEN}‚úì${NC} %s\n" "$(basename $wl)"
            fi
        done
    else
        printf "  ${YELLOW}‚óã${NC} SecLists (optional)\n"
    fi
    
    # Resultado final
    local percentage=$((checks_passed * 100 / checks_total))
    
    echo -e "\n${BOLD}Resultado:${NC}"
    printf "  Checks passou: %d/%d (%d%%)\n" $checks_passed $checks_total $percentage
    
    if [ ${#critical_failed[@]} -eq 0 ]; then
        print_success "Sistema pronto para uso!"
        return 0
    else
        print_error "Ferramentas cr√≠ticas faltando: ${critical_failed[*]}"
        print_info "Execute: ./pentest-advanced.sh --fix"
        return 1
    fi
}

# Auto-fix de problemas comuns
auto_fix() {
    print_section "Auto-Fix de Problemas"
    
    print_step "Diagnosticando problemas..."
    
    # Fix 1: PATH do Go
    if ! echo "$PATH" | grep -q "/usr/local/go/bin"; then
        print_step "Corrigindo PATH do Go..."
        export PATH=$PATH:/usr/local/go/bin:$HOME/go/bin
        echo 'export PATH=$PATH:/usr/local/go/bin:$HOME/go/bin' >> ~/.bashrc
        print_success "PATH do Go corrigido"
    fi
    
    # Fix 2: Permiss√µes
    print_step "Corrigindo permiss√µes..."
    chmod +x "$FRAMEWORK_DIR"/*.py 2>/dev/null || true
    chmod +x "$FRAMEWORK_DIR"/*.sh 2>/dev/null || true
    print_success "Permiss√µes corrigidas"
    
    # Fix 3: Depend√™ncias quebradas
    if [ "$PACKAGE_MANAGER" = "apt" ]; then
        print_step "Corrigindo depend√™ncias quebradas..."
        sudo apt --fix-broken install -y &>> "$LOG_FILE"
        sudo dpkg --configure -a &>> "$LOG_FILE"
        print_success "Depend√™ncias corrigidas"
    fi
    
    # Fix 4: Reinstalar ferramentas faltantes
    print_step "Verificando ferramentas faltantes..."
    local ESSENTIAL=("nuclei" "httpx" "subfinder")
    local missing=()
    
    for tool in "${ESSENTIAL[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
            missing+=("$tool")
        fi
    done
    
    if [ ${#missing[@]} -gt 0 ]; then
        print_step "Reinstalando: ${missing[*]}"
        install_go_tools_optimized
    fi
    
    print_success "Auto-fix conclu√≠do!"
}

# Docker support
create_dockerfile() {
    print_section "Criando Dockerfile"
    
    cat > "$FRAMEWORK_DIR/Dockerfile" << 'EOF'
FROM kalilinux/kali-rolling:latest

LABEL maintainer="BUCH CTF Team"
LABEL description="Professional Web Pentest Framework"

# Atualizar e instalar depend√™ncias
RUN apt-get update && apt-get install -y \
    curl wget git build-essential \
    python3 python3-pip python3-venv \
    nmap sqlmap nikto \
    golang-go \
    && rm -rf /var/lib/apt/lists/*

# Configurar Go
ENV PATH="${PATH}:/usr/local/go/bin:/root/go/bin"
ENV GOPATH="/root/go"

# Criar diret√≥rio de trabalho
WORKDIR /pentest

# Copiar framework
COPY . /pentest/

# Instalar depend√™ncias Python
RUN python3 -m venv venv && \
    . venv/bin/activate && \
    pip install --upgrade pip && \
    pip install -r requirements.txt

# Instalar ferramentas Go
RUN go install github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest && \
    go install github.com/projectdiscovery/httpx/cmd/httpx@latest && \
    go install github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest

# Atualizar templates do Nuclei
RUN nuclei -update-templates

ENTRYPOINT ["/bin/bash"]
EOF
    
    print_success "Dockerfile criado"
    print_info "Build: docker build -t pentest-framework ."
    print_info "Run: docker run -it pentest-framework"
}

# Menu interativo
interactive_menu() {
    while true; do
        print_banner
        echo -e "${BOLD}Menu Principal:${NC}"
        echo ""
        echo "  ${GREEN}1)${NC} Instala√ß√£o Completa"
        echo "  ${GREEN}2)${NC} Health Check"
        echo "  ${GREEN}3)${NC} Auto-Fix de Problemas"
        echo "  ${GREEN}4)${NC} Atualizar Ferramentas"
        echo "  ${GREEN}5)${NC} Criar Dockerfile"
        echo "  ${GREEN}6)${NC} Backup do Sistema"
        echo "  ${GREEN}7)${NC} Rollback"
        echo "  ${GREEN}8)${NC} Executar Scan"
        echo "  ${GREEN}9)${NC} Ver Logs"
        echo "  ${RED}0)${NC} Sair"
        echo ""
        read -p "Escolha uma op√ß√£o: " choice
        
        case $choice in
            1) install_all_enhanced ;;
            2) health_check; read -p "Pressione ENTER para continuar..." ;;
            3) auto_fix; read -p "Pressione ENTER para continuar..." ;;
            4) update_tools_enhanced; read -p "Pressione ENTER para continuar..." ;;
            5) create_dockerfile; read -p "Pressione ENTER para continuar..." ;;
            6) create_backup; read -p "Pressione ENTER para continuar..." ;;
            7) rollback; read -p "Pressione ENTER para continuar..." ;;
            8) 
                echo ""
                read -p "URL/Domain: " target
                if [ -n "$target" ]; then
                    run_scan -u "$target" --recon
                fi
                read -p "Pressione ENTER para continuar..."
                ;;
            9) 
                if [ -f "$LOG_FILE" ]; then
                    less "$LOG_FILE"
                else
                    print_warning "Nenhum log encontrado"
                    read -p "Pressione ENTER para continuar..."
                fi
                ;;
            0) 
                print_info "Saindo..."
                exit 0
                ;;
            *)
                print_error "Op√ß√£o inv√°lida"
                sleep 2
                ;;
        esac
    done
}

# Instala√ß√£o completa melhorada
install_all_enhanced() {
    print_banner
    
    log "===== INICIANDO INSTALA√á√ÉO ====="
    
    # Verifica√ß√µes pr√©-instala√ß√£o
    check_root
    check_disk_space || exit 1
    check_internet || exit 1
    check_os || exit 1
    check_python_version || exit 1
    
    # Criar backup antes de instalar
    create_backup
    
    # Instala√ß√£o
    update_system
    install_go
    install_apt_tools_parallel
    install_go_tools_optimized
    install_python_tools_enhanced
    install_seclists_enhanced
    clone_git_repos_enhanced
    setup_venv_optimized
    
    # Verifica√ß√£o final
    if health_check; then
        print_section "Instala√ß√£o Completa!"
        print_success "Framework instalado com sucesso!"
        echo ""
        print_info "Logs salvos em: $LOG_FILE"
        print_info "Para usar: ./pentest-advanced.sh -u https://target.com --recon"
        print_info "Ou: ./pentest-advanced.sh --menu (modo interativo)"
    else
        print_warning "Instala√ß√£o conclu√≠da com alguns problemas"
        print_info "Execute: ./pentest-advanced.sh --fix"
    fi
    
    log "===== INSTALA√á√ÉO FINALIZADA ====="
}

# Atualiza√ß√£o melhorada
update_tools_enhanced() {
    print_section "Atualizando Ferramentas"
    
    create_backup
    
    # Sistema
    print_step "Atualizando sistema..."
    case $PACKAGE_MANAGER in
        apt)
            sudo apt update -qq && sudo apt upgrade -y -qq &>> "$LOG_FILE"
            ;;
        pacman)
            sudo pacman -Syu --noconfirm &>> "$LOG_FILE"
            ;;
        dnf)
            sudo dnf upgrade -y &>> "$LOG_FILE"
            ;;
    esac
    
    # Go tools
    if command -v go &> /dev/null; then
        print_step "Atualizando ferramentas Go..."
        export PATH=$PATH:/usr/local/go/bin:$HOME/go/bin
        
        local GO_TOOLS_UPDATE=(
            "github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest"
            "github.com/projectdiscovery/httpx/cmd/httpx@latest"
            "github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest"
        )
        
        for tool in "${GO_TOOLS_UPDATE[@]}"; do
            go install -v "$tool" &>> "$LOG_FILE" || true
        done
        
        nuclei -update-templates -silent &>> "$LOG_FILE" || true
    fi
    
    # Git repos
    print_step "Atualizando reposit√≥rios..."
    find "$TOOLS_DIR" -name ".git" -type d | while read -r git_dir; do
        repo_dir=$(dirname "$git_dir")
        (cd "$repo_dir" && git pull -q &>> "$LOG_FILE" || true)
    done
    
    # Python
    if [ -d "$VENV_DIR" ]; then
        print_step "Atualizando pacotes Python..."
        source "$VENV_DIR/bin/activate"
        pip install --upgrade pip -q &>> "$LOG_FILE"
        [ -f "$FRAMEWORK_DIR/requirements.txt" ] && \
            pip install -r "$FRAMEWORK_DIR/requirements.txt" --upgrade -q &>> "$LOG_FILE"
    fi
    
    print_success "Atualiza√ß√£o conclu√≠da!"
}

# Executar scan
run_scan() {
    if [ -d "$VENV_DIR" ]; then
        source "$VENV_DIR/bin/activate"
    else
        print_error "Ambiente virtual n√£o encontrado"
        print_info "Execute: ./pentest-advanced.sh --install"
        exit 1
    fi
    
    if [ ! -f "$FRAMEWORK_DIR/main.py" ]; then
        print_error "main.py n√£o encontrado"
        exit 1
    fi
    
    cd "$FRAMEWORK_DIR"
    python3 main.py "$@"
}

# Ajuda melhorada
show_help() {
    print_banner
    cat << EOF
${BOLD}USO:${NC}
  ./pentest-advanced.sh [OP√á√ïES]

${BOLD}INSTALA√á√ÉO:${NC}
  --install, -i          Instala√ß√£o completa (otimizada e paralela)
  --check, -c            Health check do sistema
  --fix, -f              Auto-fix de problemas comuns
  --update, -u           Atualizar todas as ferramentas
  --menu, -m             Menu interativo

${BOLD}DOCKER:${NC}
  --dockerfile           Criar Dockerfile
  --docker-build         Build imagem Docker
  --docker-run           Executar container Docker

${BOLD}BACKUP/ROLLBACK:${NC}
  --backup               Criar backup
  --rollback             Restaurar √∫ltimo backup
  --list-backups         Listar backups dispon√≠veis

${BOLD}SCANNING (passa direto para Python):${NC}
  -u, --url URL          Target URL
  -d, --domain DOM       Target domain
  --full                 Scan completo
  --recon                Reconhecimento
  --subdomains           Enumera√ß√£o de subdom√≠nios
  --vuln                 Scan de vulnerabilidades (Nuclei)
  --ports                Port scanning
  --crawl                Web crawling
  --fuzz                 Directory fuzzing
  -o, --output DIR       Diret√≥rio de sa√≠da
  -v, --verbose          Modo verbose

${BOLD}LOGS:${NC}
  --logs                 Ver √∫ltimo log
  --clean-logs           Limpar logs antigos

${BOLD}EXEMPLOS:${NC}
  ${GREEN}# Instala√ß√£o${NC}
  ./pentest-advanced.sh --install
  ./pentest-advanced.sh --menu

  ${GREEN}# Scanning${NC}
  ./pentest-advanced.sh -u https://target.com --recon
  ./pentest-advanced.sh -d target.com --full -o ./results
  ./pentest-advanced.sh -u https://target.com --vuln --nuclei-tags cve

  ${GREEN}# Manuten√ß√£o${NC}
  ./pentest-advanced.sh --check
  ./pentest-advanced.sh --fix
  ./pentest-advanced.sh --update

EOF
}

# Main
main() {
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi
    
    case "$1" in
        --install|-i)
            install_all_enhanced
            ;;
        --check|-c)
            health_check
            ;;
        --fix|-f)
            auto_fix
            ;;
        --update)
            update_tools_enhanced
            ;;
        --menu|-m)
            interactive_menu
            ;;
        --dockerfile)
            create_dockerfile
            ;;
        --backup)
            create_backup
            ;;
        --rollback)
            rollback
            ;;
        --list-backups)
            ls -lh "$BACKUP_DIR"/*.tar.gz 2>/dev/null || print_info "Nenhum backup encontrado"
            ;;
        --logs)
            less "$LOG_FILE" 2>/dev/null || print_warning "Nenhum log encontrado"
            ;;
        --clean-logs)
            rm -f "$LOG_DIR"/*.log
            print_success "Logs limpos"
            ;;
        --help|-h)
            show_help
            ;;
        *)
            run_scan "$@"
            ;;
    esac
}

# Trap para cleanup
trap 'echo -e "\n${YELLOW}Script interrompido${NC}"; exit 130' INT TERM

main "$@"

