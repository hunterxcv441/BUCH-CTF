#!/bin/bash

################################################################################
# Smart Scan Script - Parameter Discovery + Intelligent Fuzzing
# Vers√£o: 1.0
# Criado por: BUCH CTF Team
# 
# Este script executa:
# 1. Descoberta de par√¢metros com Arjun
# 2. Fuzzing inteligente nos par√¢metros encontrados
# 3. Testes de SQLi, XSS, Command Injection, etc.
################################################################################

set -e

# Cores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
BOLD='\033[1m'
NC='\033[0m'

# Vari√°veis
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
FRAMEWORK_DIR="$SCRIPT_DIR"
VENV_DIR="$FRAMEWORK_DIR/venv"
OUTPUT_DIR="$FRAMEWORK_DIR/output/smart_scan_$(date +%Y%m%d_%H%M%S)"
SECLISTS_DIR="/usr/share/seclists"
TEMP_DIR="/tmp/smart_scan_$$"

# Adicionar PATH para ferramentas Python
export PATH="$PATH:$HOME/.local/bin:/usr/local/bin"

# Wordlists do SecLists (com fallbacks)
SQLI_WORDLIST="$SECLISTS_DIR/Fuzzing/SQLi/Generic-SQLi.txt"
XSS_WORDLIST="$SECLISTS_DIR/Fuzzing/XSS/XSS-Jhaddix.txt"
CMDI_WORDLIST="$SECLISTS_DIR/Fuzzing/command-injection-commix.txt"
LFI_WORDLIST="$SECLISTS_DIR/Fuzzing/LFI/LFI-Jhaddix.txt"
XXE_WORDLIST="$SECLISTS_DIR/Fuzzing/XXE-Fuzzing.txt"
SSRF_WORDLIST="$SECLISTS_DIR/Fuzzing/SSRF-Injection.txt"
GENERIC_WORDLIST="$SECLISTS_DIR/Discovery/Web-Content/burp-parameter-names.txt"

# Verificar e ajustar caminhos das wordlists
find_wordlist() {
    local wl_name=$1
    local possible_paths=(
        "$SECLISTS_DIR/$wl_name"
        "$SECLISTS_DIR/Fuzzing/$wl_name"
        "/usr/share/wordlists/seclists/$wl_name"
        "/usr/share/seclists/$wl_name"
    )
    
    for path in "${possible_paths[@]}"; do
        if [ -f "$path" ]; then
            echo "$path"
            return 0
        fi
    done
    
    # Buscar recursivamente
    local found=$(find "$SECLISTS_DIR" -name "$(basename $wl_name)" -type f 2>/dev/null | head -1)
    if [ -n "$found" ]; then
        echo "$found"
        return 0
    fi
    
    return 1
}

# Ajustar wordlists automaticamente
[ ! -f "$XSS_WORDLIST" ] && XSS_WORDLIST=$(find_wordlist "XSS/XSS-Jhaddix.txt" || find_wordlist "XSS-BruteLogic.txt" || echo "$SECLISTS_DIR/Discovery/Web-Content/common.txt")
[ ! -f "$CMDI_WORDLIST" ] && CMDI_WORDLIST=$(find_wordlist "command-injection-commix.txt" || echo "$SECLISTS_DIR/Fuzzing/SQLi/Generic-SQLi.txt")
[ ! -f "$LFI_WORDLIST" ] && LFI_WORDLIST=$(find_wordlist "LFI/LFI-Jhaddix.txt" || echo "$SECLISTS_DIR/Discovery/Web-Content/common.txt")
[ ! -f "$XXE_WORDLIST" ] && XXE_WORDLIST=$(find_wordlist "XXE-Fuzzing.txt" || echo "$SECLISTS_DIR/Fuzzing/SQLi/Generic-SQLi.txt")
[ ! -f "$SSRF_WORDLIST" ] && SSRF_WORDLIST=$(find_wordlist "SSRF-Injection.txt" || echo "$SECLISTS_DIR/Discovery/Web-Content/common.txt")

mkdir -p "$OUTPUT_DIR" "$TEMP_DIR"

# Fun√ß√µes
print_banner() {
    clear
    echo -e "${GREEN}"
    cat << "EOF"
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                                            ‚ïë
‚ïë        üéØ Smart Parameter Discovery & Fuzzing Engine üéØ                  ‚ïë
‚ïë                                                                            ‚ïë
‚ïë                    Arjun + SecLists Integration                           ‚ïë
‚ïë                    BUCH CTF Team                                           ‚ïë
‚ïë                                                                            ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
EOF
    echo -e "${NC}"
}

print_section() {
    echo -e "\n${CYAN}${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${CYAN}${BOLD}  $1${NC}"
    echo -e "${CYAN}${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}\n"
}

print_step() {
    echo -e "${BLUE}[*]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[‚úì]${NC} $1"
}

print_error() {
    echo -e "${RED}[‚úó]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[‚ö†]${NC} $1"
}

print_info() {
    echo -e "${CYAN}[‚Ñπ]${NC} $1"
}

print_vuln() {
    echo -e "${RED}${BOLD}[!!! VULNERABILITY FOUND !!!]${NC} $1"
}

# Verificar depend√™ncias
check_dependencies() {
    print_section "Verificando Depend√™ncias"
    
    local missing=()
    local optional_missing=()
    
    # Ferramentas essenciais
    local ESSENTIAL_TOOLS=("ffuf" "nuclei" "sqlmap")
    
    echo -e "${BOLD}Ferramentas Essenciais:${NC}"
    for tool in "${ESSENTIAL_TOOLS[@]}"; do
        if command -v "$tool" &> /dev/null; then
            print_success "$tool encontrado"
        else
            print_error "$tool n√£o encontrado"
            missing+=("$tool")
        fi
    done
    
    echo ""
    echo -e "${BOLD}Ferramentas Opcionais:${NC}"
    
    # Arjun - verificar em m√∫ltiplos locais
    local arjun_found=false
    local arjun_locations=(
        "arjun"
        "$HOME/.local/bin/arjun"
        "/usr/local/bin/arjun"
    )
    
    for loc in "${arjun_locations[@]}"; do
        if command -v "$loc" &> /dev/null || [ -x "$loc" ]; then
            print_success "arjun encontrado: $loc"
            # Criar alias ou link
            if [ "$loc" != "arjun" ]; then
                export PATH="$PATH:$(dirname $loc)"
            fi
            arjun_found=true
            break
        fi
    done
    
    if ! $arjun_found; then
        print_warning "arjun n√£o encontrado (pode usar par√¢metros comuns como fallback)"
        print_info "Instalando arjun agora..."
        
        # Tentar instalar on-the-fly
        if pip3 install arjun --user --break-system-packages &>/dev/null; then
            export PATH="$PATH:$HOME/.local/bin"
            print_success "arjun instalado!"
        else
            optional_missing+=("arjun")
        fi
    fi
    
    # Outras ferramentas opcionais
    local OPTIONAL_TOOLS=("wfuzz" "dalfox")
    for tool in "${OPTIONAL_TOOLS[@]}"; do
        if command -v "$tool" &> /dev/null; then
            print_success "$tool encontrado"
        else
            print_warning "$tool n√£o encontrado (opcional)"
            optional_missing+=("$tool")
        fi
    done
    
    # Verificar SecLists
    echo ""
    echo -e "${BOLD}Wordlists:${NC}"
    if [ ! -d "$SECLISTS_DIR" ]; then
        print_error "SecLists n√£o encontrado em $SECLISTS_DIR"
        missing+=("seclists")
    else
        print_success "SecLists encontrado: $SECLISTS_DIR"
        
        # Verificar e auto-corrigir wordlists
        local wordlists_ok=0
        local wordlists_total=6
        
        [ -f "$SQLI_WORDLIST" ] && ((wordlists_ok++)) && print_success "‚úì SQLi wordlist"
        [ -f "$XSS_WORDLIST" ] && ((wordlists_ok++)) && print_success "‚úì XSS wordlist"
        [ -f "$CMDI_WORDLIST" ] && ((wordlists_ok++)) && print_success "‚úì CMDI wordlist"
        [ -f "$LFI_WORDLIST" ] && ((wordlists_ok++)) && print_success "‚úì LFI wordlist"
        [ -f "$XXE_WORDLIST" ] && ((wordlists_ok++)) && print_success "‚úì XXE wordlist"
        [ -f "$GENERIC_WORDLIST" ] && ((wordlists_ok++)) && print_success "‚úì Generic wordlist"
        
        if [ $wordlists_ok -lt 3 ]; then
            print_warning "Poucas wordlists encontradas ($wordlists_ok/$wordlists_total)"
            print_info "Usando wordlists gen√©ricas como fallback"
        fi
    fi
    
    echo ""
    
    if [ ${#missing[@]} -gt 0 ]; then
        print_error "Ferramentas essenciais faltando: ${missing[*]}"
        print_info "Execute: ./pentest-advanced.sh --install"
        exit 1
    fi
    
    if [ ${#optional_missing[@]} -gt 0 ]; then
        print_warning "Ferramentas opcionais faltando: ${optional_missing[*]}"
        print_info "O scan continuar√° com funcionalidades reduzidas"
        echo ""
    fi
    
    print_success "Depend√™ncias essenciais OK - Pronto para scan!"
    echo ""
}

# Descobrir par√¢metros com Arjun
discover_parameters() {
    local target=$1
    local output_file="$OUTPUT_DIR/arjun_params.json"
    
    print_section "Descobrindo Par√¢metros com Arjun"
    print_step "Target: $target"
    echo ""
    
    # Executar Arjun com output completo
    print_step "Executando Arjun..."
    echo -e "${DIM}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    
    arjun -u "$target" \
        --stable \
        -oJ "$output_file" \
        -t 10 \
        --passive 2>&1 | while IFS= read -r line; do
        echo "  $line"
    done | tee "$OUTPUT_DIR/arjun_full.log"
    
    echo -e "${DIM}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo ""
    
    if [ -f "$output_file" ]; then
        print_success "Arjun conclu√≠do. Resultados salvos."
        
        # Mostrar JSON completo formatado
        if command -v jq &> /dev/null && [ -s "$output_file" ]; then
            echo ""
            print_info "Output JSON completo:"
            echo -e "${CYAN}"
            jq '.' "$output_file" 2>/dev/null || cat "$output_file"
            echo -e "${NC}"
        fi
        
        # Extrair par√¢metros encontrados
        local params=$(python3 -c "
import json, sys
try:
    with open('$output_file', 'r') as f:
        data = json.load(f)
        if isinstance(data, list) and len(data) > 0:
            params = data[0].get('params', [])
            if params:
                print(' '.join(params))
            else:
                print('')
        else:
            print('')
except:
    print('')
" 2>/dev/null)
        
        if [ -n "$params" ]; then
            print_success "Par√¢metros descobertos: $params"
            echo "$params" > "$OUTPUT_DIR/parameters.txt"
            echo "$params"
        else
            print_warning "Nenhum par√¢metro encontrado pelo Arjun"
            echo ""
        fi
    else
        print_warning "Arquivo de output do Arjun n√£o criado"
        echo ""
    fi
}

# Fuzzing inteligente de par√¢metros
fuzz_parameter() {
    local target=$1
    local param=$2
    local wordlist=$3
    local attack_type=$4
    local output_prefix="$OUTPUT_DIR/${attack_type}_${param}"
    
    print_step "Testando $attack_type no par√¢metro: $param"
    echo ""
    
    # Verificar se wordlist existe
    if [ ! -f "$wordlist" ]; then
        print_warning "Wordlist n√£o encontrada: $wordlist"
        return 1
    fi
    
    # Preparar URL base
    local base_url="$target"
    if [[ "$base_url" == *"?"* ]]; then
        base_url="${base_url}&${param}=FUZZ"
    else
        base_url="${base_url}?${param}=FUZZ"
    fi
    
    print_info "URL: $base_url"
    print_info "Wordlist: $(basename $wordlist) ($(wc -l < $wordlist) payloads)"
    print_info "Attack Type: $attack_type"
    echo ""
    
    # Executar ffuf com output completo
    if command -v ffuf &> /dev/null; then
        print_step "Executando ffuf..."
        echo -e "${DIM}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
        
        # Executar ffuf com output vis√≠vel
        ffuf -u "$base_url" \
            -w "$wordlist" \
            -mc 200,301,302,401,403,500 \
            -fc 404 \
            -t 20 \
            -o "$output_prefix.json" \
            -of json \
            -c \
            2>&1 | while IFS= read -r line; do
            echo "  $line"
        done | tee "$output_prefix.log"
        
        echo -e "${DIM}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
        echo ""
        
        # Mostrar resultados detalhados do JSON
        if [ -f "$output_prefix.json" ]; then
            if command -v jq &> /dev/null; then
                local results=$(jq '.results // []' "$output_prefix.json" 2>/dev/null)
                local hits=$(echo "$results" | jq 'length' 2>/dev/null)
                
                if [ "$hits" -gt 0 ]; then
                    print_vuln "$attack_type: $hits resultados encontrados no par√¢metro '$param'"
                    echo "[$(date)] $attack_type: $hits hits em $param" >> "$OUTPUT_DIR/vulnerabilities.txt"
                    
                    # Mostrar top 20 resultados formatados
                    echo ""
                    print_info "Top resultados (detalhados):"
                    echo -e "${YELLOW}"
                    echo "$results" | jq -r '.[:20] | .[] | 
                        "  [\(.status)] \(.url)\n" +
                        "    ‚îî‚îÄ Length: \(.length) | Words: \(.words) | Lines: \(.lines)\n" +
                        "    ‚îî‚îÄ Time: \(.duration)ms"
                    ' 2>/dev/null || echo "$results" | jq '.[:20]'
                    echo -e "${NC}"
                    
                    # Salvar lista de URLs vulner√°veis
                    echo "$results" | jq -r '.[] | .url' > "${output_prefix}_urls.txt" 2>/dev/null
                    print_info "URLs salvas em: ${output_prefix}_urls.txt"
                else
                    print_info "$attack_type: Nenhum resultado interessante encontrado"
                fi
            else
                # Fallback sem jq
                print_info "Resultados salvos em: $output_prefix.json"
                cat "$output_prefix.json"
            fi
        fi
    fi
    
    echo ""
}

# Testar SQLi em par√¢metro
test_sqli() {
    local target=$1
    local param=$2
    
    print_section "SQLMap - Teste de SQL Injection no Par√¢metro: $param"
    
    # Preparar URL
    local test_url="$target"
    if [[ "$test_url" == *"?"* ]]; then
        test_url="${test_url}&${param}=1"
    else
        test_url="${test_url}?${param}=1"
    fi
    
    print_info "Target URL: $test_url"
    print_info "Par√¢metro: $param"
    echo ""
    
    # Executar SQLMap com output completo
    if command -v sqlmap &> /dev/null; then
        local sqlmap_output="$OUTPUT_DIR/sqlmap_${param}"
        mkdir -p "$sqlmap_output"
        
        print_step "Executando SQLMap (--level=2 --risk=2)..."
        echo -e "${DIM}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
        
        # Executar SQLMap com output completo e colorido
        sqlmap -u "$test_url" \
            --batch \
            --level=2 \
            --risk=2 \
            --technique=BEUST \
            --threads=5 \
            --output-dir="$sqlmap_output" \
            --flush-session \
            --answers="follow=Y" \
            -v 1 \
            2>&1 | while IFS= read -r line; do
            # Destacar linhas importantes
            if [[ "$line" =~ "vulnerable" ]] || [[ "$line" =~ "injectable" ]]; then
                echo -e "${RED}  $line${NC}"
            elif [[ "$line" =~ "Parameter:" ]] || [[ "$line" =~ "Type:" ]] || [[ "$line" =~ "Title:" ]]; then
                echo -e "${YELLOW}  $line${NC}"
            elif [[ "$line" =~ "Payload:" ]]; then
                echo -e "${CYAN}  $line${NC}"
            else
                echo "  $line"
            fi
        done | tee "$OUTPUT_DIR/sqlmap_${param}_full.log"
        
        echo -e "${DIM}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
        echo ""
        
        # Analisar e exibir resultados detalhados
        local log_file="$OUTPUT_DIR/sqlmap_${param}_full.log"
        
        if grep -q "is vulnerable\|injectable" "$log_file"; then
            print_vuln "SQLi CONFIRMADO no par√¢metro '$param'!"
            echo "[$(date)] SQLi CONFIRMED em $param" >> "$OUTPUT_DIR/vulnerabilities.txt"
            
            echo ""
            print_info "Detalhes da Vulnerabilidade:"
            echo -e "${RED}${BOLD}"
            grep -A 5 "Parameter:\|Type:\|Title:\|Payload:" "$log_file" | sed 's/^/  /'
            echo -e "${NC}"
            
            # Tentar extrair informa√ß√µes do banco
            print_step "Tentando extrair informa√ß√µes do banco de dados..."
            sqlmap -u "$test_url" \
                --batch \
                --current-db \
                --current-user \
                --output-dir="$sqlmap_output" \
                2>&1 | while IFS= read -r line; do
                echo "  $line"
            done | tee -a "$OUTPUT_DIR/sqlmap_${param}_extraction.log"
            
        elif grep -q "does not seem to be injectable\|not injectable" "$log_file"; then
            print_info "SQLMap: Par√¢metro '$param' n√£o parece ser vulner√°vel a SQLi"
        else
            print_warning "SQLMap: Resultado inconclusivo para '$param'"
        fi
        
        # Listar todos os arquivos gerados
        if [ -d "$sqlmap_output" ]; then
            echo ""
            print_info "Arquivos SQLMap gerados:"
            find "$sqlmap_output" -type f | while read -r file; do
                echo "  üìÑ $file"
            done
        fi
    else
        print_error "SQLMap n√£o encontrado"
    fi
    
    echo ""
}

# Testar XSS em par√¢metro
test_xss() {
    local target=$1
    local param=$2
    
    print_section "Dalfox - Teste de XSS no Par√¢metro: $param"
    
    # Preparar URL
    local test_url="$target"
    if [[ "$test_url" == *"?"* ]]; then
        test_url="${test_url}&${param}=FUZZ"
    else
        test_url="${test_url}?${param}=FUZZ"
    fi
    
    print_info "Target URL: $test_url"
    print_info "Par√¢metro: $param"
    echo ""
    
    # Executar dalfox com output completo
    if command -v dalfox &> /dev/null; then
        print_step "Executando dalfox (XSS Scanner)..."
        echo -e "${DIM}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
        
        # Executar dalfox com output verboso
        dalfox url "$test_url" \
            --output "$OUTPUT_DIR/dalfox_${param}.txt" \
            --format json \
            --output-file "$OUTPUT_DIR/dalfox_${param}.json" \
            --mining-dict \
            --deep-domxss \
            --follow-redirects \
            --worker 10 \
            2>&1 | while IFS= read -r line; do
            # Colorir linhas importantes
            if [[ "$line" =~ "POC" ]] || [[ "$line" =~ "VULN" ]] || [[ "$line" =~ "Triggered" ]]; then
                echo -e "${RED}  $line${NC}"
            elif [[ "$line" =~ "Reflected" ]] || [[ "$line" =~ "Found" ]]; then
                echo -e "${YELLOW}  $line${NC}"
            elif [[ "$line" =~ "Payload:" ]]; then
                echo -e "${CYAN}  $line${NC}"
            else
                echo "  $line"
            fi
        done | tee "$OUTPUT_DIR/dalfox_${param}_full.log"
        
        echo -e "${DIM}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
        echo ""
        
        # Exibir resultados detalhados do JSON
        if [ -f "$OUTPUT_DIR/dalfox_${param}.json" ] && [ -s "$OUTPUT_DIR/dalfox_${param}.json" ]; then
            print_vuln "XSS encontrado no par√¢metro '$param'!"
            echo "[$(date)] XSS potential em $param" >> "$OUTPUT_DIR/vulnerabilities.txt"
            
            echo ""
            print_info "Detalhes das Vulnerabilidades XSS:"
            
            if command -v jq &> /dev/null; then
                echo -e "${RED}${BOLD}"
                jq -r '.[] | 
                    "  [XSS FOUND]\n" +
                    "    Type: \(.type // "Unknown")\n" +
                    "    Payload: \(.payload)\n" +
                    "    POC: \(.poc)\n" +
                    "    Param: \(.param // "N/A")\n" +
                    "    CWE: \(.cwe // "N/A")\n" +
                    "    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
                ' "$OUTPUT_DIR/dalfox_${param}.json" 2>/dev/null
                echo -e "${NC}"
            else
                cat "$OUTPUT_DIR/dalfox_${param}.json"
            fi
            
        elif [ -f "$OUTPUT_DIR/dalfox_${param}.txt" ] && [ -s "$OUTPUT_DIR/dalfox_${param}.txt" ]; then
            print_vuln "XSS potencial encontrado no par√¢metro '$param'!"
            echo "[$(date)] XSS potential em $param" >> "$OUTPUT_DIR/vulnerabilities.txt"
            
            echo ""
            print_info "Output do Dalfox:"
            echo -e "${YELLOW}"
            cat "$OUTPUT_DIR/dalfox_${param}.txt" | sed 's/^/  /'
            echo -e "${NC}"
        else
            print_info "Dalfox: Nenhum XSS encontrado em '$param'"
        fi
        
        # Mostrar arquivos gerados
        echo ""
        print_info "Arquivos Dalfox gerados:"
        ls -lh "$OUTPUT_DIR"/dalfox_${param}* 2>/dev/null | awk '{print "  üìÑ " $9 " (" $5 ")"}'
        
    else
        print_error "Dalfox n√£o encontrado"
    fi
    
    echo ""
}

# Scan completo de um par√¢metro
comprehensive_param_scan() {
    local target=$1
    local param=$2
    
    print_section "Scan Completo do Par√¢metro: $param"
    
    # 1. SQLi Fuzzing
    if [ -f "$SQLI_WORDLIST" ]; then
        fuzz_parameter "$target" "$param" "$SQLI_WORDLIST" "SQLi"
        test_sqli "$target" "$param"
    fi
    
    # 2. XSS Fuzzing
    if [ -f "$XSS_WORDLIST" ]; then
        fuzz_parameter "$target" "$param" "$XSS_WORDLIST" "XSS"
        test_xss "$target" "$param"
    fi
    
    # 3. Command Injection
    if [ -f "$CMDI_WORDLIST" ]; then
        fuzz_parameter "$target" "$param" "$CMDI_WORDLIST" "CMDI"
    fi
    
    # 4. LFI/Path Traversal
    if [ -f "$LFI_WORDLIST" ]; then
        fuzz_parameter "$target" "$param" "$LFI_WORDLIST" "LFI"
    fi
    
    # 5. XXE (se aplic√°vel)
    if [ -f "$XXE_WORDLIST" ]; then
        fuzz_parameter "$target" "$param" "$XXE_WORDLIST" "XXE"
    fi
    
    # 6. SSRF
    if [ -f "$SSRF_WORDLIST" ]; then
        fuzz_parameter "$target" "$param" "$SSRF_WORDLIST" "SSRF"
    fi
}

# Scan inteligente completo
smart_scan() {
    local target=$1
    
    print_banner
    print_info "Target: $target"
    print_info "Output: $OUTPUT_DIR"
    
    # Verificar depend√™ncias
    check_dependencies
    
    # 1. Descobrir par√¢metros
    local params=""
    
    # Verificar se arjun est√° dispon√≠vel
    if command -v arjun &> /dev/null || [ -x "$HOME/.local/bin/arjun" ]; then
        params=$(discover_parameters "$target")
    else
        print_warning "Arjun n√£o dispon√≠vel. Pulando descoberta autom√°tica."
    fi
    
    if [ -z "$params" ]; then
        print_warning "Nenhum par√¢metro encontrado via Arjun. Usando par√¢metros comuns..."
        
        # Lista de par√¢metros comuns
        local common_params=(
            "id" "page" "name" "user" "search" "q" "query" "keyword"
            "cat" "category" "item" "product" "file" "view" "action"
            "redirect" "url" "path" "debug" "test" "admin" "login"
        )
        
        # Tentar par√¢metros do SecLists
        if [ -f "$GENERIC_WORDLIST" ]; then
            print_step "Carregando par√¢metros do SecLists..."
            local seclists_params=$(head -30 "$GENERIC_WORDLIST" | grep -v '^#' | tr '\n' ' ')
            params="$seclists_params"
        else
            # Fallback para lista hard-coded
            print_step "Usando lista de par√¢metros comuns..."
            params="${common_params[*]}"
        fi
        
        print_info "Par√¢metros a testar: $(echo $params | wc -w) par√¢metros"
        echo "$params" | tr ' ' '\n' | head -10 | sed 's/^/  ‚Ä¢ /'
        [ $(echo $params | wc -w) -gt 10 ] && echo "  ... e mais $(( $(echo $params | wc -w) - 10 ))"
        echo ""
    fi
    
    # 2. Testar cada par√¢metro encontrado
    print_section "Iniciando Fuzzing Inteligente"
    
    local param_count=0
    for param in $params; do
        ((param_count++))
        comprehensive_param_scan "$target" "$param"
        
        # Pequena pausa entre par√¢metros
        sleep 1
    done
    
    # 3. Executar Nuclei nos resultados
    print_section "Nuclei - Valida√ß√£o Final de Vulnerabilidades"
    
    if command -v nuclei &> /dev/null; then
        print_step "Executando Nuclei no target..."
        print_info "Templates: $HOME/nuclei-templates"
        print_info "Severidade: critical, high, medium"
        echo ""
        echo -e "${DIM}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
        
        nuclei -u "$target" \
            -t "$HOME/nuclei-templates" \
            -severity critical,high,medium \
            -o "$OUTPUT_DIR/nuclei_results.txt" \
            -json-export "$OUTPUT_DIR/nuclei_results.json" \
            -stats \
            -v \
            2>&1 | while IFS= read -r line; do
            # Colorir por severidade
            if [[ "$line" =~ "critical" ]]; then
                echo -e "${RED}${BOLD}  $line${NC}"
            elif [[ "$line" =~ "high" ]]; then
                echo -e "${RED}  $line${NC}"
            elif [[ "$line" =~ "medium" ]]; then
                echo -e "${YELLOW}  $line${NC}"
            elif [[ "$line" =~ "info" ]]; then
                echo -e "${BLUE}  $line${NC}"
            else
                echo "  $line"
            fi
        done | tee "$OUTPUT_DIR/nuclei_full.log"
        
        echo -e "${DIM}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
        echo ""
        
        # Exibir resumo detalhado do Nuclei
        if [ -f "$OUTPUT_DIR/nuclei_results.json" ] && [ -s "$OUTPUT_DIR/nuclei_results.json" ]; then
            print_success "Nuclei encontrou vulnerabilidades!"
            
            if command -v jq &> /dev/null; then
                # Contar por severidade
                local critical=$(jq '[.[] | select(.info.severity=="critical")] | length' "$OUTPUT_DIR/nuclei_results.json" 2>/dev/null || echo 0)
                local high=$(jq '[.[] | select(.info.severity=="high")] | length' "$OUTPUT_DIR/nuclei_results.json" 2>/dev/null || echo 0)
                local medium=$(jq '[.[] | select(.info.severity=="medium")] | length' "$OUTPUT_DIR/nuclei_results.json" 2>/dev/null || echo 0)
                
                echo ""
                print_info "Resumo por Severidade:"
                echo -e "  ${RED}${BOLD}Critical: $critical${NC}"
                echo -e "  ${RED}High: $high${NC}"
                echo -e "  ${YELLOW}Medium: $medium${NC}"
                
                # Mostrar detalhes de cada vulnerabilidade
                echo ""
                print_info "Detalhes das Vulnerabilidades Encontradas:"
                echo -e "${CYAN}"
                jq -r '.[] | 
                    "  [\(.info.severity | ascii_upcase)] \(.info.name)\n" +
                    "    Template: \(.template-id)\n" +
                    "    URL: \(.matched-at // .host)\n" +
                    "    Description: \(.info.description // "N/A")\n" +
                    "    CWE: \(.info.classification.cwe // "N/A")\n" +
                    "    CVE: \(.info.classification.cve // "N/A")\n" +
                    "    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
                ' "$OUTPUT_DIR/nuclei_results.json" 2>/dev/null
                echo -e "${NC}"
            fi
        elif [ -f "$OUTPUT_DIR/nuclei_results.txt" ] && [ -s "$OUTPUT_DIR/nuclei_results.txt" ]; then
            print_info "Resultados do Nuclei (formato texto):"
            echo -e "${CYAN}"
            cat "$OUTPUT_DIR/nuclei_results.txt" | sed 's/^/  /'
            echo -e "${NC}"
        else
            print_info "Nuclei: Nenhuma vulnerabilidade encontrada nos templates testados"
        fi
    else
        print_warning "Nuclei n√£o encontrado - pulando valida√ß√£o"
    fi
    
    echo ""
    
    # 4. Gerar relat√≥rio
    generate_report "$target" "$param_count"
    
    # Cleanup
    rm -rf "$TEMP_DIR"
}

# Gerar relat√≥rio
generate_report() {
    local target=$1
    local param_count=$2
    
    print_section "Gerando Relat√≥rio"
    
    local report_file="$OUTPUT_DIR/REPORT.txt"
    
    cat > "$report_file" << EOF
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        SMART PARAMETER DISCOVERY & FUZZING REPORT
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Target: $target
Date: $(date)
Parameters Tested: $param_count
Output Directory: $OUTPUT_DIR

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
VULNERABILITIES FOUND
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

EOF
    
    if [ -f "$OUTPUT_DIR/vulnerabilities.txt" ]; then
        cat "$OUTPUT_DIR/vulnerabilities.txt" >> "$report_file"
    else
        echo "No vulnerabilities detected (or low-confidence findings)" >> "$report_file"
    fi
    
    cat >> "$report_file" << EOF

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
FILES GENERATED
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

EOF
    
    find "$OUTPUT_DIR" -type f -name "*.json" -o -name "*.txt" -o -name "*.log" | while read file; do
        echo "  - $(basename $file) ($(du -h $file | cut -f1))" >> "$report_file"
    done
    
    cat >> "$report_file" << EOF

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
RECOMMENDATIONS
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

1. Review all findings manually
2. Check SQLMap logs for confirmed SQLi
3. Test XSS findings in browser
4. Verify command injection results
5. Check Nuclei output for additional vulnerabilities

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
EOF
    
    print_success "Relat√≥rio gerado: $report_file"
    
    # Mostrar resumo
    echo ""
    print_section "RESUMO DO SCAN"
    cat "$report_file"
}

# Help
show_help() {
    print_banner
    cat << EOF
${BOLD}USO:${NC}
  ./pentest-smart-scan.sh [TARGET_URL]

${BOLD}DESCRI√á√ÉO:${NC}
  Este script executa um scan inteligente completo:
  
  1. ${CYAN}Descoberta de Par√¢metros${NC} (Arjun)
  2. ${CYAN}Fuzzing Inteligente${NC} (ffuf + wfuzz com SecLists)
     - SQLi testing
     - XSS testing
     - Command Injection
     - LFI/Path Traversal
     - XXE testing
     - SSRF testing
  3. ${CYAN}Valida√ß√£o Automatizada${NC} (SQLMap + dalfox)
  4. ${CYAN}Verifica√ß√£o Final${NC} (Nuclei)
  5. ${CYAN}Relat√≥rio Detalhado${NC}

${BOLD}WORDLISTS UTILIZADAS:${NC}
  - SQLi: SecLists/Fuzzing/SQLi/Generic-SQLi.txt
  - XSS: SecLists/Fuzzing/XSS/XSS-Jhaddix.txt
  - Command Injection: SecLists/Fuzzing/command-injection-commix.txt
  - LFI: SecLists/Fuzzing/LFI/LFI-Jhaddix.txt
  - XXE: SecLists/Fuzzing/XXE-Fuzzing.txt
  - SSRF: SecLists/Fuzzing/SSRF-Injection.txt
  - Generic Params: SecLists/Discovery/Web-Content/burp-parameter-names.txt

${BOLD}EXEMPLOS:${NC}
  ${GREEN}# Scan completo${NC}
  ./pentest-smart-scan.sh https://target.com/page.php

  ${GREEN}# Scan em endpoint com par√¢metros existentes${NC}
  ./pentest-smart-scan.sh "https://target.com/search.php?q=test"

  ${GREEN}# Scan em API${NC}
  ./pentest-smart-scan.sh https://api.target.com/v1/users

${BOLD}REQUISITOS:${NC}
  - arjun (descoberta de par√¢metros)
  - ffuf (fuzzing)
  - wfuzz (fuzzing alternativo)
  - sqlmap (SQLi testing)
  - dalfox (XSS testing)
  - nuclei (valida√ß√£o)
  - SecLists (/usr/share/seclists)

${BOLD}OUTPUT:${NC}
  Todos os resultados s√£o salvos em:
  $FRAMEWORK_DIR/output/smart_scan_TIMESTAMP/

EOF
}

# Main
main() {
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi
    
    local target=$1
    
    if [[ "$target" == "--help" ]] || [[ "$target" == "-h" ]]; then
        show_help
        exit 0
    fi
    
    # Validar URL
    if [[ ! "$target" =~ ^https?:// ]]; then
        print_error "URL inv√°lida. Use: http:// ou https://"
        exit 1
    fi
    
    # Executar scan
    smart_scan "$target"
}

# Trap para cleanup
trap 'echo -e "\n${YELLOW}Scan interrompido${NC}"; rm -rf "$TEMP_DIR"; exit 130' INT TERM

main "$@"

