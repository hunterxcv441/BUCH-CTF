"""
Wrapper para executar ferramentas externas e parsear resultados.
"""

import subprocess
import json
import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, TYPE_CHECKING
from pathlib import Path
import tempfile
import sys

from core.colors import Colors

if TYPE_CHECKING:
    from core.installer import ToolInstaller


class ToolManager:
    """Gerencia execução de ferramentas externas"""
    
    def __init__(self, installer: 'ToolInstaller'):
        self.installer = installer
        self.temp_dir = Path(tempfile.gettempdir()) / "pentest_framework"
        self.temp_dir.mkdir(exist_ok=True, parents=True)
    
    def run_command(
        self,
        cmd: List[str],
        timeout: int = 300,
        capture_output: bool = True,
        shell: bool = False
    ) -> subprocess.CompletedProcess:
        """Executa comando e retorna resultado"""
        try:
            result = subprocess.run(
                cmd,
                capture_output=capture_output,
                text=True,
                timeout=timeout,
                check=False,
                shell=shell
            )
            return result
        except subprocess.TimeoutExpired:
            raise TimeoutError(f"Comando expirou após {timeout}s: {' '.join(cmd) if isinstance(cmd, list) else cmd}")
        except Exception as e:
            raise RuntimeError(f"Erro ao executar comando: {e}")
    
    # ===========================================
    # SUBFINDER - Subdomain Enumeration
    # ===========================================
    def run_subfinder(
        self,
        domain: str,
        output_file: Optional[str] = None
    ) -> List[str]:
        """Executa subfinder e retorna lista de subdomínios"""
        cmd = ['subfinder', '-d', domain, '-silent', '-all']
        
        if output_file:
            cmd.extend(['-o', output_file])
        
        try:
            result = self.run_command(cmd, timeout=300)
            subdomains = result.stdout.strip().split('\n')
            return [s.strip() for s in subdomains if s.strip()]
        except Exception as e:
            print(f"  {Colors.error(f'Erro no subfinder: {e}')}")
            return []
    
    # ===========================================
    # HTTPX - HTTP Probing
    # ===========================================
    def run_httpx(
        self,
        targets: List[str],
        options: Dict[str, Any] = None
    ) -> List[Dict[str, Any]]:
        """Executa httpx e retorna resultados"""
        options = options or {}
        
        # Criar arquivo temporário com targets
        targets_file = self.temp_dir / 'httpx_targets.txt'
        targets_file.write_text('\n'.join(targets), encoding='utf-8')
        
        cmd = [
            'httpx',
            '-l', str(targets_file),
            '-silent',
            '-json',
            '-title',
            '-status-code',
            '-tech-detect',
            '-cdn'
        ]
        
        # Adicionar opções customizadas
        if options.get('follow_redirects'):
            cmd.append('-follow-redirects')
        
        if options.get('threads'):
            cmd.extend(['-threads', str(options['threads'])])
        
        try:
            result = self.run_command(cmd, timeout=600)
            
            # Parsear JSON output
            results = []
            for line in result.stdout.strip().split('\n'):
                if line:
                    try:
                        results.append(json.loads(line))
                    except json.JSONDecodeError:
                        continue
            
            return results
        except Exception as e:
            print(f"  {Colors.error(f'Erro no httpx: {e}')}")
            return []
    
    # ===========================================
    # NUCLEI - Vulnerability Scanner
    # ===========================================
    def run_nuclei(
        self,
        target: str,
        tags: Optional[List[str]] = None,
        severity: Optional[List[str]] = None,
        templates: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """Executa nuclei e retorna vulnerabilidades"""
        output_file = self.temp_dir / 'nuclei_output.json'
        
        cmd = [
            'nuclei',
            '-u', target,
            '-json',
            '-o', str(output_file),
            '-silent'
        ]
        
        if tags:
            cmd.extend(['-tags', ','.join(tags)])
        
        if severity:
            cmd.extend(['-severity', ','.join(severity)])
        
        if templates:
            cmd.extend(['-t', templates])
        
        try:
            self.run_command(cmd, timeout=600)
            
            # Ler resultados
            if output_file.exists():
                results = []
                with open(output_file) as f:
                    for line in f:
                        if line.strip():
                            try:
                                results.append(json.loads(line))
                            except json.JSONDecodeError:
                                continue
                return results
            
            return []
        except Exception as e:
            print(f"  {Colors.error(f'Erro no nuclei: {e}')}")
            return []
    
    # ===========================================
    # NMAP - Port Scanner
    # ===========================================
    def run_nmap(
        self,
        target: str,
        ports: Optional[str] = None,
        fast: bool = True,
        service_detection: bool = False
    ) -> Dict[str, Any]:
        """Executa nmap e retorna resultados"""
        output_file = self.temp_dir / 'nmap_output.xml'
        
        cmd = ['nmap', target, '-oX', str(output_file)]
        
        if fast:
            cmd.append('-F')
        elif ports:
            cmd.extend(['-p', ports])
        else:
            cmd.extend(['-p-'])
        
        if service_detection:
            cmd.append('-sV')
        
        cmd.extend(['-T4', '--open'])
        
        try:
            self.run_command(cmd, timeout=600)
            
            # Parsear XML
            if output_file.exists():
                tree = ET.parse(output_file)
                root = tree.getroot()
                
                results = {
                    'host': target,
                    'ports': []
                }
                
                for port in root.findall('.//port'):
                    state = port.find('state')
                    service = port.find('service')
                    
                    if state is not None and state.get('state') == 'open':
                        port_info = {
                            'port': port.get('portid'),
                            'protocol': port.get('protocol'),
                            'state': state.get('state'),
                            'service': service.get('name') if service is not None else 'unknown',
                            'version': service.get('product', '') if service is not None else ''
                        }
                        results['ports'].append(port_info)
                
                return results
            
            return {'host': target, 'ports': []}
        except Exception as e:
            print(f"  {Colors.error(f'Erro no nmap: {e}')}")
            return {'host': target, 'ports': []}
    
    # ===========================================
    # SQLMAP - SQL Injection Scanner
    # ===========================================
    def run_sqlmap(
        self,
        url: str,
        options: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """Executa sqlmap e retorna resultados"""
        options = options or {}
        
        cmd = [
            'sqlmap',
            '-u', url,
            '--batch',
            '--random-agent',
            '--level', str(options.get('level', 1)),
            '--risk', str(options.get('risk', 1)),
            '--threads', str(options.get('threads', 5))
        ]
        
        if options.get('dbms'):
            cmd.extend(['--dbms', options['dbms']])
        
        if options.get('data'):
            cmd.extend(['--data', options['data']])
        
        try:
            result = self.run_command(cmd, timeout=600)
            
            # Parsear output
            vulnerable = 'sqlmap identified the following injection' in result.stdout.lower()
            injection_type = None
            
            if vulnerable:
                # Tentar extrair tipo de injeção
                for line in result.stdout.split('\n'):
                    if 'Type:' in line:
                        injection_type = line.split('Type:')[1].strip()
                        break
            
            return {
                'url': url,
                'vulnerable': vulnerable,
                'injection_type': injection_type,
                'output': result.stdout
            }
        except Exception as e:
            print(f"  {Colors.error(f'Erro no sqlmap: {e}')}")
            return {'url': url, 'vulnerable': False, 'output': str(e)}
    
    # ===========================================
    # WPSCAN - WordPress Scanner
    # ===========================================
    def run_wpscan(
        self,
        url: str,
        enumerate: str = 'vp,vt,u',
        api_token: Optional[str] = None
    ) -> Dict[str, Any]:
        """Executa wpscan e retorna resultados"""
        output_file = self.temp_dir / 'wpscan_output.json'
        
        cmd = [
            'wpscan',
            '--url', url,
            '--enumerate', enumerate,
            '--format', 'json',
            '--output', str(output_file),
            '--random-user-agent'
        ]
        
        if api_token:
            cmd.extend(['--api-token', api_token])
        
        try:
            self.run_command(cmd, timeout=600)
            
            # Ler JSON
            if output_file.exists():
                with open(output_file) as f:
                    return json.load(f)
            
            return {}
        except Exception as e:
            print(f"  {Colors.error(f'Erro no wpscan: {e}')}")
            return {}
    
    # ===========================================
    # FFUF - Web Fuzzer
    # ===========================================
    def run_ffuf(
        self,
        url: str,
        wordlist: str,
        extensions: Optional[List[str]] = None,
        match_codes: str = '200,204,301,302,307,401,403,405',
        threads: int = 50
    ) -> List[Dict[str, Any]]:
        """Executa ffuf e retorna resultados"""
        output_file = self.temp_dir / 'ffuf_output.json'
        
        # Garantir FUZZ na URL
        if 'FUZZ' not in url:
            url = url.rstrip('/') + '/FUZZ'
        
        cmd = [
            'ffuf',
            '-u', url,
            '-w', wordlist,
            '-mc', match_codes,
            '-t', str(threads),
            '-o', str(output_file),
            '-of', 'json',
            '-s'  # Silent
        ]
        
        if extensions:
            cmd.extend(['-e', ','.join(extensions)])
        
        try:
            self.run_command(cmd, timeout=600)
            
            # Parsear JSON
            if output_file.exists():
                with open(output_file) as f:
                    data = json.load(f)
                    return data.get('results', [])
            
            return []
        except Exception as e:
            print(f"  {Colors.error(f'Erro no ffuf: {e}')}")
            return []
    
    # ===========================================
    # KATANA - Web Crawler
    # ===========================================
    def run_katana(
        self,
        url: str,
        depth: int = 3,
        js_crawl: bool = True,
        headless: bool = False
    ) -> List[str]:
        """Executa katana e retorna URLs"""
        cmd = [
            'katana',
            '-u', url,
            '-d', str(depth),
            '-silent'
        ]
        
        if js_crawl:
            cmd.append('-js-crawl')
        
        if headless:
            cmd.append('-headless')
        
        try:
            result = self.run_command(cmd, timeout=300)
            urls = result.stdout.strip().split('\n')
            return [u.strip() for u in urls if u.strip()]
        except Exception as e:
            print(f"  {Colors.error(f'Erro no katana: {e}')}")
            return []
    
    # ===========================================
    # WAYBACKURLS - Historical URLs
    # ===========================================
    def run_waybackurls(self, domain: str) -> List[str]:
        """Executa waybackurls e retorna URLs históricas"""
        cmd = ['waybackurls', domain]
        
        try:
            result = self.run_command(cmd, timeout=300)
            urls = result.stdout.strip().split('\n')
            return [u.strip() for u in urls if u.strip()]
        except Exception as e:
            print(f"  {Colors.error(f'Erro no waybackurls: {e}')}")
            return []
    
    # ===========================================
    # GAU - GetAllURLs
    # ===========================================
    def run_gau(self, domain: str, providers: Optional[List[str]] = None) -> List[str]:
        """Executa gau e retorna URLs"""
        cmd = ['gau', domain]
        
        if providers:
            cmd.extend(['--providers', ','.join(providers)])
        
        try:
            result = self.run_command(cmd, timeout=300)
            urls = result.stdout.strip().split('\n')
            return [u.strip() for u in urls if u.strip()]
        except Exception as e:
            print(f"  {Colors.error(f'Erro no gau: {e}')}")
            return []
    
    # ===========================================
    # ARJUN - Parameter Discovery
    # ===========================================
    def run_arjun(
        self,
        url: str,
        method: str = 'GET',
        wordlist: Optional[str] = None
    ) -> List[str]:
        """Executa arjun e retorna parâmetros"""
        output_file = self.temp_dir / 'arjun_output.json'
        
        cmd = [
            'arjun',
            '-u', url,
            '-m', method,
            '-oJ', str(output_file),
            '--stable'
        ]
        
        if wordlist:
            cmd.extend(['-w', wordlist])
        
        try:
            self.run_command(cmd, timeout=300)
            
            # Ler JSON
            if output_file.exists():
                with open(output_file) as f:
                    data = json.load(f)
                    # Arjun retorna formato: {url: [params]}
                    for params in data.values():
                        if isinstance(params, list):
                            return params
                    return []
            
            return []
        except Exception as e:
            print(f"  {Colors.error(f'Erro no arjun: {e}')}")
            return []
    
    # ===========================================
    # DALFOX - XSS Scanner
    # ===========================================
    def run_dalfox(
        self,
        urls: List[str],
        blind_url: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """Executa dalfox para XSS testing"""
        # Criar arquivo com URLs
        urls_file = self.temp_dir / 'dalfox_urls.txt'
        urls_file.write_text('\n'.join(urls), encoding='utf-8')
        
        output_file = self.temp_dir / 'dalfox_output.json'
        
        cmd = [
            'dalfox',
            'file', str(urls_file),
            '--silence',
            '--output', str(output_file),
            '--format', 'json'
        ]
        
        if blind_url:
            cmd.extend(['--blind', blind_url])
        
        try:
            self.run_command(cmd, timeout=600)
            
            # Parsear resultados
            results = []
            if output_file.exists():
                with open(output_file) as f:
                    for line in f:
                        if line.strip():
                            try:
                                results.append(json.loads(line))
                            except json.JSONDecodeError:
                                continue
            
            return results
        except Exception as e:
            print(f"  {Colors.error(f'Erro no dalfox: {e}')}")
            return []
    
    # ===========================================
    # NIKTO - Web Server Scanner
    # ===========================================
    def run_nikto(self, url: str) -> Dict[str, Any]:
        """Executa nikto e retorna resultados"""
        output_file = self.temp_dir / 'nikto_output.json'
        
        cmd = [
            'nikto',
            '-h', url,
            '-Format', 'json',
            '-output', str(output_file)
        ]
        
        try:
            self.run_command(cmd, timeout=600)
            
            if output_file.exists():
                with open(output_file) as f:
                    return json.load(f)
            
            return {}
        except Exception as e:
            print(f"  {Colors.error(f'Erro no nikto: {e}')}")
            return {}
    
    # ===========================================
    # WHATWEB - Technology Detection
    # ===========================================
    def run_whatweb(self, url: str) -> Dict[str, Any]:
        """Executa whatweb e retorna tecnologias detectadas"""
        cmd = [
            'whatweb',
            '--color=never',
            '--log-json=-',
            url
        ]
        
        try:
            result = self.run_command(cmd, timeout=60)
            
            # Parsear JSON output
            if result.stdout:
                try:
                    return json.loads(result.stdout)
                except json.JSONDecodeError:
                    return {'raw': result.stdout}
            
            return {}
        except Exception as e:
            print(f"  {Colors.error(f'Erro no whatweb: {e}')}")
            return {}
    
    # ===========================================
    # DIRSEARCH - Directory Brute Force
    # ===========================================
    def run_dirsearch(
        self,
        url: str,
        wordlist: Optional[str] = None,
        extensions: Optional[List[str]] = None
    ) -> List[Dict[str, Any]]:
        """Executa dirsearch e retorna resultados"""
        dirsearch_path = self.installer.tools_dir / 'dirsearch' / 'dirsearch.py'
        
        if not dirsearch_path.exists():
            print(f"  {Colors.warning('Dirsearch não encontrado')}")
            return []
        
        output_file = self.temp_dir / 'dirsearch_output.json'
        
        cmd = [
            sys.executable,
            str(dirsearch_path),
            '-u', url,
            '--format', 'json',
            '-o', str(output_file)
        ]
        
        if wordlist:
            cmd.extend(['-w', wordlist])
        
        if extensions:
            cmd.extend(['-e', ','.join(extensions)])
        
        try:
            self.run_command(cmd, timeout=600)
            
            if output_file.exists():
                with open(output_file) as f:
                    return json.load(f)
            
            return []
        except Exception as e:
            print(f"  {Colors.error(f'Erro no dirsearch: {e}')}")
            return []

