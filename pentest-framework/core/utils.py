"""
Utility functions for the framework.
"""

import os
import sys
import json
import yaml
from pathlib import Path
from typing import Any, Dict, List, Optional
from datetime import datetime
import hashlib


def is_root() -> bool:
    """Check if running as root"""
    return os.geteuid() == 0 if hasattr(os, 'geteuid') else False


def ensure_directory(path: str) -> Path:
    """Ensure directory exists, create if not"""
    directory = Path(path)
    directory.mkdir(parents=True, exist_ok=True)
    return directory


def read_json(filepath: str) -> Dict[str, Any]:
    """Read JSON file"""
    try:
        with open(filepath, 'r') as f:
            return json.load(f)
    except Exception as e:
        raise RuntimeError(f"Error reading JSON file {filepath}: {e}")


def write_json(filepath: str, data: Dict[str, Any], indent: int = 2):
    """Write data to JSON file"""
    try:
        with open(filepath, 'w') as f:
            json.dump(data, f, indent=indent)
    except Exception as e:
        raise RuntimeError(f"Error writing JSON file {filepath}: {e}")


def read_yaml(filepath: str) -> Dict[str, Any]:
    """Read YAML file"""
    try:
        with open(filepath, 'r') as f:
            return yaml.safe_load(f)
    except Exception as e:
        raise RuntimeError(f"Error reading YAML file {filepath}: {e}")


def write_yaml(filepath: str, data: Dict[str, Any]):
    """Write data to YAML file"""
    try:
        with open(filepath, 'w') as f:
            yaml.dump(data, f, default_flow_style=False)
    except Exception as e:
        raise RuntimeError(f"Error writing YAML file {filepath}: {e}")


def read_lines(filepath: str, skip_empty: bool = True, skip_comments: bool = True) -> List[str]:
    """Read lines from file"""
    try:
        with open(filepath, 'r') as f:
            lines = f.readlines()
        
        result = []
        for line in lines:
            line = line.strip()
            
            if skip_empty and not line:
                continue
            
            if skip_comments and line.startswith('#'):
                continue
            
            result.append(line)
        
        return result
    except Exception as e:
        raise RuntimeError(f"Error reading file {filepath}: {e}")


def write_lines(filepath: str, lines: List[str]):
    """Write lines to file"""
    try:
        with open(filepath, 'w') as f:
            f.write('\n'.join(lines))
    except Exception as e:
        raise RuntimeError(f"Error writing file {filepath}: {e}")


def get_timestamp() -> str:
    """Get current timestamp string"""
    return datetime.now().strftime("%Y%m%d_%H%M%S")


def get_readable_timestamp() -> str:
    """Get human-readable timestamp"""
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")


def calculate_md5(filepath: str) -> str:
    """Calculate MD5 hash of file"""
    hash_md5 = hashlib.md5()
    try:
        with open(filepath, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_md5.update(chunk)
        return hash_md5.hexdigest()
    except Exception as e:
        raise RuntimeError(f"Error calculating MD5 for {filepath}: {e}")


def sanitize_filename(filename: str) -> str:
    """Sanitize filename by removing invalid characters"""
    invalid_chars = '<>:"/\\|?*'
    for char in invalid_chars:
        filename = filename.replace(char, '_')
    return filename


def parse_url(url: str) -> Dict[str, str]:
    """Parse URL into components"""
    from urllib.parse import urlparse
    
    parsed = urlparse(url)
    return {
        'scheme': parsed.scheme,
        'netloc': parsed.netloc,
        'hostname': parsed.hostname,
        'port': parsed.port,
        'path': parsed.path,
        'params': parsed.params,
        'query': parsed.query,
        'fragment': parsed.fragment,
        'username': parsed.username,
        'password': parsed.password
    }


def extract_domain(url: str) -> str:
    """Extract domain from URL"""
    parsed = parse_url(url)
    return parsed['hostname'] or parsed['netloc']


def is_valid_url(url: str) -> bool:
    """Check if URL is valid"""
    try:
        parsed = parse_url(url)
        return bool(parsed['scheme']) and bool(parsed['netloc'])
    except:
        return False


def format_bytes(bytes_count: int) -> str:
    """Format bytes into human-readable string"""
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if bytes_count < 1024.0:
            return f"{bytes_count:.2f} {unit}"
        bytes_count /= 1024.0
    return f"{bytes_count:.2f} PB"


def format_duration(seconds: float) -> str:
    """Format duration in seconds into human-readable string"""
    if seconds < 60:
        return f"{seconds:.2f}s"
    elif seconds < 3600:
        minutes = seconds / 60
        return f"{minutes:.2f}m"
    else:
        hours = seconds / 3600
        return f"{hours:.2f}h"


class ProgressTracker:
    """Simple progress tracker"""
    
    def __init__(self, total: int, prefix: str = "Progress"):
        self.total = total
        self.current = 0
        self.prefix = prefix
    
    def update(self, increment: int = 1):
        """Update progress"""
        self.current += increment
        percentage = (self.current / self.total) * 100 if self.total > 0 else 0
        print(f"\r{self.prefix}: {self.current}/{self.total} ({percentage:.1f}%)", end='', flush=True)
    
    def finish(self):
        """Finish progress"""
        print()


def get_wordlist_path(name: str, seclists_path: str = "/usr/share/seclists") -> Optional[str]:
    """Get path to common wordlists"""
    wordlists = {
        'common': f'{seclists_path}/Discovery/Web-Content/common.txt',
        'directories': f'{seclists_path}/Discovery/Web-Content/directory-list-2.3-medium.txt',
        'files': f'{seclists_path}/Discovery/Web-Content/raft-large-files.txt',
        'subdomains': f'{seclists_path}/Discovery/DNS/subdomains-top1million-110000.txt',
        'parameters': f'{seclists_path}/Discovery/Web-Content/burp-parameter-names.txt',
        'xss': f'{seclists_path}/Fuzzing/XSS/XSS-Jhaddix.txt',
        'lfi': f'{seclists_path}/Fuzzing/LFI/LFI-Jhaddix.txt',
        'sqli': f'{seclists_path}/Fuzzing/SQLi/Generic-SQLi.txt',
    }
    
    path = wordlists.get(name)
    if path and Path(path).exists():
        return path
    
    return None

