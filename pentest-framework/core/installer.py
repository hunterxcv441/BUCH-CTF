"""
Sistema de verificaÃ§Ã£o e instalaÃ§Ã£o automÃ¡tica de ferramentas.
Verifica se cada ferramenta estÃ¡ instalada e instala se necessÃ¡rio.
"""

import os
import sys
import subprocess
import shutil
import platform
from typing import Dict, List, Tuple, Optional
from pathlib import Path
import requests
from tqdm import tqdm

from core.colors import Colors


class ToolInstaller:
    """Gerencia instalaÃ§Ã£o de ferramentas de pentest"""
    
    def __init__(self, tools_dir: str = "./tools"):
        self.tools_dir = Path(tools_dir)
        self.tools_dir.mkdir(exist_ok=True, parents=True)
        self.go_bin = Path.home() / "go" / "bin"
        self.os_type = platform.system().lower()
        
        # Definir todas as ferramentas necessÃ¡rias
        self.tools = {
            # APT/DNF packages (Linux)
            'apt': {
                'nmap': {'package': 'nmap', 'check_cmd': 'nmap --version'},
                'masscan': {'package': 'masscan', 'check_cmd': 'masscan --version'},
                'nikto': {'package': 'nikto', 'check_cmd': 'nikto -Version'},
                'sqlmap': {'package': 'sqlmap', 'check_cmd': 'sqlmap --version'},
                'hydra': {'package': 'hydra', 'check_cmd': 'hydra -h'},
                'whatweb': {'package': 'whatweb', 'check_cmd': 'whatweb --version'},
                'git': {'package': 'git', 'check_cmd': 'git --version'},
                'curl': {'package': 'curl', 'check_cmd': 'curl --version'},
                'wget': {'package': 'wget', 'check_cmd': 'wget --version'},
            },
            
            # Go tools
            'go': {
                'nuclei': {
                    'install': 'go install -v github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest',
                    'check_cmd': 'nuclei -version'
                },
                'httpx': {
                    'install': 'go install -v github.com/projectdiscovery/httpx/cmd/httpx@latest',
                    'check_cmd': 'httpx -version'
                },
                'subfinder': {
                    'install': 'go install -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest',
                    'check_cmd': 'subfinder -version'
                },
                'katana': {
                    'install': 'go install github.com/projectdiscovery/katana/cmd/katana@latest',
                    'check_cmd': 'katana -version'
                },
                'waybackurls': {
                    'install': 'go install github.com/tomnomnom/waybackurls@latest',
                    'check_cmd': 'waybackurls -h'
                },
                'gau': {
                    'install': 'go install github.com/lc/gau/v2/cmd/gau@latest',
                    'check_cmd': 'gau --version'
                },
                'dalfox': {
                    'install': 'go install github.com/hahwul/dalfox/v2@latest',
                    'check_cmd': 'dalfox version'
                },
                'assetfinder': {
                    'install': 'go install github.com/tomnomnom/assetfinder@latest',
                    'check_cmd': 'assetfinder -h'
                },
                'ffuf': {
                    'install': 'go install github.com/ffuf/ffuf@latest',
                    'check_cmd': 'ffuf -V'
                },
            },
            
            # Python tools (pip/pipx)
            'python': {
                'arjun': {
                    'install': 'pip3 install arjun',
                    'check_cmd': 'arjun -h'
                },
            },
            
            # Git repositories
            'git': {
                'dirsearch': {
                    'repo': 'https://github.com/maurosoria/dirsearch.git',
                    'check_path': 'dirsearch/dirsearch.py'
                },
                'commix': {
                    'repo': 'https://github.com/commixproject/commix.git',
                    'check_path': 'commix/commix.py'
                },
                'jwt_tool': {
                    'repo': 'https://github.com/ticarpi/jwt_tool',
                    'check_path': 'jwt_tool/jwt_tool.py'
                },
            }
        }
    
    def check_tool_installed(self, check_cmd: str) -> bool:
        """Verifica se uma ferramenta estÃ¡ instalada"""
        try:
            cmd_parts = check_cmd.split()
            subprocess.run(
                cmd_parts,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                timeout=5
            )
            return True
        except (subprocess.TimeoutExpired, FileNotFoundError, PermissionError):
            return False
    
    def install_apt_package(self, package: str) -> bool:
        """Instala pacote via apt (Linux)"""
        if self.os_type != 'linux':
            print(f"  {Colors.warning('Apt packages only supported on Linux')}")
            return False
        
        print(f"  ðŸ“¦ Instalando {package} via apt...")
        try:
            # Verificar se tem sudo
            has_sudo = shutil.which('sudo') is not None
            
            cmd = ['sudo', 'apt', 'install', '-y', package] if has_sudo else ['apt', 'install', '-y', package]
            
            subprocess.run(
                cmd,
                check=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            return True
        except subprocess.CalledProcessError as e:
            print(f"  {Colors.error(f'Erro ao instalar {package}: {e}')}")
            return False
    
    def install_go_tool(self, name: str, install_cmd: str) -> bool:
        """Instala ferramenta Go"""
        print(f"  ðŸ”§ Instalando {name} via Go...")
        try:
            # Executar comando de instalaÃ§Ã£o
            subprocess.run(
                install_cmd,
                shell=True,
                check=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                timeout=300
            )
            
            # Copiar para /usr/local/bin se necessÃ¡rio (Linux only)
            if self.os_type == 'linux':
                go_binary = self.go_bin / name
                if go_binary.exists():
                    try:
                        subprocess.run(
                            ['sudo', 'cp', str(go_binary), '/usr/local/bin/'],
                            check=True,
                            stdout=subprocess.DEVNULL,
                            stderr=subprocess.DEVNULL
                        )
                    except:
                        pass  # NÃ£o Ã© crÃ­tico
            
            return True
        except subprocess.CalledProcessError as e:
            print(f"  {Colors.error(f'Erro ao instalar {name}: {e}')}")
            return False
        except subprocess.TimeoutExpired:
            print(f"  {Colors.error(f'Timeout ao instalar {name}')}")
            return False
    
    def install_python_tool(self, name: str, install_cmd: str) -> bool:
        """Instala ferramenta Python"""
        print(f"  ðŸ Instalando {name} via pip...")
        try:
            subprocess.run(
                install_cmd,
                shell=True,
                check=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                timeout=300
            )
            return True
        except subprocess.CalledProcessError as e:
            print(f"  {Colors.error(f'Erro ao instalar {name}: {e}')}")
            return False
        except subprocess.TimeoutExpired:
            print(f"  {Colors.error(f'Timeout ao instalar {name}')}")
            return False
    
    def clone_git_repo(self, name: str, repo_url: str) -> bool:
        """Clona repositÃ³rio Git"""
        print(f"  ðŸ“¥ Clonando {name}...")
        repo_path = self.tools_dir / name
        
        if repo_path.exists():
            print(f"  {Colors.success(f'{name} jÃ¡ existe')}")
            return True
        
        try:
            subprocess.run(
                ['git', 'clone', repo_url, str(repo_path)],
                check=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                timeout=300
            )
            
            # Instalar requirements se existir
            requirements = repo_path / 'requirements.txt'
            if requirements.exists():
                print(f"  ðŸ“¦ Instalando requirements para {name}...")
                subprocess.run(
                    [sys.executable, '-m', 'pip', 'install', '-r', str(requirements)],
                    check=True,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    timeout=300
                )
            
            return True
        except subprocess.CalledProcessError as e:
            print(f"  {Colors.error(f'Erro ao clonar {name}: {e}')}")
            return False
        except subprocess.TimeoutExpired:
            print(f"  {Colors.error(f'Timeout ao clonar {name}')}")
            return False
    
    def ensure_go_installed(self) -> bool:
        """Garante que Go estÃ¡ instalado"""
        if shutil.which('go'):
            print(f"  {Colors.success('Go jÃ¡ instalado')}")
            return True
        
        print(f"\n{Colors.info('Go nÃ£o encontrado. Instalando...')}")
        
        if self.os_type == 'linux':
            return self._install_go_linux()
        elif self.os_type == 'windows':
            print(f"  {Colors.warning('Por favor, instale Go manualmente: https://go.dev/dl/')}")
            return False
        elif self.os_type == 'darwin':
            print(f"  {Colors.warning('Por favor, instale Go via brew: brew install go')}")
            return False
        else:
            print(f"  {Colors.warning('Sistema operacional nÃ£o suportado para instalaÃ§Ã£o automÃ¡tica de Go')}")
            return False
    
    def _install_go_linux(self) -> bool:
        """Instala Go no Linux"""
        try:
            # Download Go
            go_version = "1.21.5"
            go_tar = f"go{go_version}.linux-amd64.tar.gz"
            url = f"https://go.dev/dl/{go_tar}"
            
            print(f"  Baixando Go {go_version}...")
            response = requests.get(url, stream=True)
            total_size = int(response.headers.get('content-length', 0))
            
            with open(go_tar, 'wb') as f, tqdm(
                total=total_size, unit='B', unit_scale=True, desc="Download"
            ) as pbar:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
                    pbar.update(len(chunk))
            
            # Extrair e instalar
            print(f"  Instalando Go...")
            subprocess.run(['sudo', 'rm', '-rf', '/usr/local/go'], 
                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            subprocess.run(
                ['sudo', 'tar', '-C', '/usr/local', '-xzf', go_tar],
                check=True
            )
            
            # Configurar PATH
            go_path = 'export PATH=$PATH:/usr/local/go/bin:$HOME/go/bin'
            bashrc = Path.home() / '.bashrc'
            
            with open(bashrc, 'a') as f:
                f.write(f'\n{go_path}\n')
            
            os.environ['PATH'] += f':/usr/local/go/bin:{self.go_bin}'
            
            os.remove(go_tar)
            print(f"  {Colors.success('Go instalado com sucesso')}")
            return True
            
        except Exception as e:
            print(f"  {Colors.error(f'Erro ao instalar Go: {e}')}")
            return False
    
    def install_seclists(self) -> bool:
        """Instala SecLists se necessÃ¡rio"""
        if self.os_type != 'linux':
            print(f"  {Colors.info('SecLists: clone manualmente de https://github.com/danielmiessler/SecLists')}")
            return False
        
        seclists_path = Path('/usr/share/seclists')
        
        if seclists_path.exists():
            print(f"  {Colors.success('SecLists jÃ¡ instalado')}")
            return True
        
        print("ðŸ“š Instalando SecLists...")
        try:
            subprocess.run(
                ['sudo', 'apt', 'install', '-y', 'seclists'],
                check=True,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                timeout=300
            )
            return True
        except:
            # Fallback: clonar do GitHub
            print("  Tentando clonar do GitHub...")
            try:
                subprocess.run([
                    'sudo', 'git', 'clone', '--depth', '1',
                    'https://github.com/danielmiessler/SecLists.git',
                    '/usr/share/seclists'
                ], check=True, timeout=300)
                return True
            except:
                print(f"  {Colors.warning('Falha ao instalar SecLists')}")
                return False
    
    def check_and_install_all(self) -> Dict[str, bool]:
        """Verifica e instala todas as ferramentas necessÃ¡rias"""
        print("\n" + "="*70)
        print(f"{Colors.header('ðŸ”§ VERIFICANDO E INSTALANDO FERRAMENTAS')}")
        print("="*70 + "\n")
        
        results = {}
        
        # Verificar sistema operacional
        print(f"{Colors.info(f'Sistema Operacional: {platform.system()} {platform.release()}')}\n")
        
        # 1. Garantir Go instalado
        print(f"{Colors.CYAN}[1/5] Verificando Go...{Colors.RESET}")
        go_installed = self.ensure_go_installed()
        
        # 2. Instalar SecLists
        if self.os_type == 'linux':
            print(f"\n{Colors.CYAN}[2/5] Verificando SecLists...{Colors.RESET}")
            self.install_seclists()
        
        # 3. Instalar ferramentas APT (apenas Linux)
        if self.os_type == 'linux':
            print(f"\n{Colors.CYAN}[3/5] Verificando ferramentas APT...{Colors.RESET}")
            
            # Atualizar apt
            print("  Atualizando apt...")
            subprocess.run(
                ['sudo', 'apt', 'update'],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            
            for name, info in self.tools['apt'].items():
                if self.check_tool_installed(info['check_cmd']):
                    print(f"  {Colors.success(f'{name} jÃ¡ instalado')}")
                    results[name] = True
                else:
                    results[name] = self.install_apt_package(info['package'])
        else:
            print(f"\n{Colors.CYAN}[3/5] Ferramentas APT (Linux only) - SKIP{Colors.RESET}")
        
        # 4. Instalar ferramentas Go
        print(f"\n{Colors.CYAN}[4/5] Verificando ferramentas Go...{Colors.RESET}")
        if go_installed:
            for name, info in self.tools['go'].items():
                if self.check_tool_installed(info['check_cmd']):
                    print(f"  {Colors.success(f'{name} jÃ¡ instalado')}")
                    results[name] = True
                else:
                    results[name] = self.install_go_tool(name, info['install'])
            
            # Atualizar templates do Nuclei
            if results.get('nuclei'):
                print(f"\n  ðŸ”„ Atualizando templates do Nuclei...")
                subprocess.run(
                    ['nuclei', '-update-templates'],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
        else:
            print(f"  {Colors.warning('Go nÃ£o disponÃ­vel. Pulando ferramentas Go.')}")
        
        # 5. Instalar ferramentas Python
        print(f"\n{Colors.CYAN}[5/5] Verificando ferramentas Python...{Colors.RESET}")
        for name, info in self.tools['python'].items():
            if self.check_tool_installed(info['check_cmd']):
                print(f"  {Colors.success(f'{name} jÃ¡ instalado')}")
                results[name] = True
            else:
                results[name] = self.install_python_tool(name, info['install'])
        
        # 6. Clonar repositÃ³rios Git
        print(f"\n{Colors.CYAN}[EXTRA] Verificando repositÃ³rios Git...{Colors.RESET}")
        for name, info in self.tools['git'].items():
            check_path = self.tools_dir / info['check_path']
            if check_path.exists():
                print(f"  {Colors.success(f'{name} jÃ¡ clonado')}")
                results[name] = True
            else:
                results[name] = self.clone_git_repo(name, info['repo'])
        
        # Resumo
        self._print_summary(results)
        
        return results
    
    def _print_summary(self, results: Dict[str, bool]):
        """Imprime resumo da instalaÃ§Ã£o"""
        print("\n" + "="*70)
        print(f"{Colors.header('ðŸ“Š RESUMO DA INSTALAÃ‡ÃƒO')}")
        print("="*70)
        
        total = len(results)
        success = sum(1 for v in results.values() if v)
        failed = [k for k, v in results.items() if not v]
        
        print(f"\n{Colors.GREEN}âœ“ Instaladas: {success}/{total}{Colors.RESET}")
        
        if failed:
            failed_str = ', '.join(failed)
            print(f"{Colors.RED}âœ— Falharam: {failed_str}{Colors.RESET}")
            print(f"\n{Colors.YELLOW}âš  Nota: Algumas ferramentas podem ser instaladas manualmente{Colors.RESET}")
        else:
            print(f"{Colors.BRIGHT_GREEN}ðŸŽ‰ Todas as ferramentas instaladas com sucesso!{Colors.RESET}")
        
        print("\n" + "="*70 + "\n")
    
    def get_tool_path(self, tool_name: str) -> str:
        """Retorna o caminho completo para uma ferramenta"""
        # Verificar se estÃ¡ no PATH
        path = shutil.which(tool_name)
        if path:
            return path
        
        # Verificar no diretÃ³rio de tools
        tool_path = self.tools_dir / tool_name
        if tool_path.exists():
            return str(tool_path)
        
        # Verificar em go/bin
        go_path = self.go_bin / tool_name
        if go_path.exists():
            return str(go_path)
        
        return tool_name  # Retornar nome e esperar que esteja no PATH
    
    def verify_core_tools(self) -> Tuple[bool, List[str]]:
        """Verifica ferramentas essenciais"""
        core_tools = ['nuclei', 'httpx', 'subfinder', 'nmap']
        missing = []
        
        for tool in core_tools:
            # Tentar verificar com check_cmd
            found = False
            for category in self.tools.values():
                if tool in category:
                    info = category[tool]
                    check_cmd = info.get('check_cmd', f'{tool} --version')
                    if self.check_tool_installed(check_cmd):
                        found = True
                        break
            
            if not found:
                missing.append(tool)
        
        return len(missing) == 0, missing

