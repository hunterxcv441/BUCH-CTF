"""
Engine principal de scanning que orquestra os mÃ³dulos.
"""

import time
from typing import Dict, Any, List
from pathlib import Path
from datetime import datetime

from core.tool_manager import ToolManager
from core.colors import Colors, print_section
from core.utils import ensure_directory, get_timestamp, extract_domain
from core.reporter import Reporter


class PentestScanner:
    """Engine principal que orquestra o pentest"""
    
    def __init__(self, tool_manager: ToolManager, args):
        self.tm = tool_manager
        self.args = args
        
        # Determinar target
        target = args.url or args.domain or args.list or 'unknown'
        if args.list:
            # Se for arquivo, usar primeiro target ou nome do arquivo
            from core.utils import read_lines
            try:
                targets = read_lines(args.list)
                target = targets[0] if targets else args.list
            except:
                target = args.list
        
        self.results = {
            'target': target,
            'start_time': datetime.now().isoformat(),
            'end_time': None,
            'duration': None,
            'modules': {}
        }
        
        # Configurar output
        if args.output:
            self.output_dir = Path(args.output)
        else:
            timestamp = get_timestamp()
            target_name = extract_domain(self.results['target'])
            self.output_dir = Path('output') / f"{target_name}_{timestamp}"
        
        ensure_directory(self.output_dir)
        
        self.reporter = Reporter(self.output_dir)
    
    def run(self):
        """Executa o scan completo"""
        start_time = time.time()
        
        print_section("ðŸŽ¯ INICIANDO PENTEST")
        print(f"Target: {Colors.CYAN}{self.results['target']}{Colors.RESET}")
        print(f"Output: {Colors.CYAN}{self.output_dir}{Colors.RESET}\n")
        
        try:
            # Determinar quais mÃ³dulos executar
            modules_to_run = self._determine_modules()
            
            # Executar mÃ³dulos
            for module_name, module_func in modules_to_run:
                try:
                    print_section(f"ðŸ” {module_name.upper()}")
                    result = module_func()
                    self.results['modules'][module_name] = result
                except Exception as e:
                    print(f"{Colors.error(f'Erro no mÃ³dulo {module_name}: {e}')}")
                    if self.args.verbose:
                        import traceback
                        traceback.print_exc()
                    self.results['modules'][module_name] = {'error': str(e)}
            
            # Finalizar
            end_time = time.time()
            self.results['end_time'] = datetime.now().isoformat()
            self.results['duration'] = end_time - start_time
            
            # Gerar relatÃ³rio
            print_section("ðŸ“Š GERANDO RELATÃ“RIO")
            self._generate_report()
            
            # Resumo final
            self._print_summary()
            
        except KeyboardInterrupt:
            print(f"\n\n{Colors.warning('Scan interrompido pelo usuÃ¡rio')}")
            raise
    
    def _determine_modules(self) -> List[tuple]:
        """Determina quais mÃ³dulos executar baseado nos args"""
        modules = []
        
        if self.args.full:
            # Scan completo - todos os mÃ³dulos
            modules = [
                ('recon', self._run_recon),
                ('subdomain', self._run_subdomain),
                ('ports', self._run_ports),
                ('crawl', self._run_crawl),
                ('fuzz', self._run_fuzz),
                ('vulnerabilities', self._run_vulnerabilities),
            ]
        else:
            # MÃ³dulos especÃ­ficos
            if self.args.recon:
                modules.append(('recon', self._run_recon))
            
            if self.args.subdomains:
                modules.append(('subdomain', self._run_subdomain))
            
            if self.args.ports:
                modules.append(('ports', self._run_ports))
            
            if self.args.crawl:
                modules.append(('crawl', self._run_crawl))
            
            if self.args.fuzz:
                modules.append(('fuzz', self._run_fuzz))
            
            if self.args.vuln:
                modules.append(('vulnerabilities', self._run_vulnerabilities))
            
            if self.args.wordpress:
                modules.append(('wordpress', self._run_wordpress))
            
            if self.args.xss:
                modules.append(('xss', self._run_xss))
            
            if self.args.sqli:
                modules.append(('sqli', self._run_sqli))
            
            if self.args.params:
                modules.append(('parameters', self._run_params))
        
        # Se nenhum mÃ³dulo especificado, fazer recon bÃ¡sico
        if not modules:
            modules.append(('recon', self._run_recon))
        
        return modules
    
    def _run_recon(self) -> Dict[str, Any]:
        """MÃ³dulo de reconhecimento"""
        from modules.recon import ReconScanner
        
        scanner = ReconScanner(self.tm)
        return scanner.scan(self.results['target'])
    
    def _run_subdomain(self) -> Dict[str, Any]:
        """MÃ³dulo de enumeraÃ§Ã£o de subdomÃ­nios"""
        from modules.subdomain import SubdomainScanner
        
        domain = extract_domain(self.results['target'])
        scanner = SubdomainScanner(self.tm)
        return scanner.scan(domain)
    
    def _run_ports(self) -> Dict[str, Any]:
        """MÃ³dulo de port scanning"""
        from modules.ports import PortScanner
        
        target = extract_domain(self.results['target'])
        scanner = PortScanner(self.tm)
        return scanner.scan(target, fast=not self.args.full)
    
    def _run_crawl(self) -> Dict[str, Any]:
        """MÃ³dulo de web crawling"""
        from modules.crawler import WebCrawler
        
        scanner = WebCrawler(self.tm)
        return scanner.scan(self.results['target'])
    
    def _run_fuzz(self) -> Dict[str, Any]:
        """MÃ³dulo de fuzzing"""
        from modules.fuzzer import DirectoryFuzzer
        
        scanner = DirectoryFuzzer(self.tm)
        wordlist = self.args.wordlist
        return scanner.scan(self.results['target'], wordlist=wordlist)
    
    def _run_vulnerabilities(self) -> Dict[str, Any]:
        """MÃ³dulo de scanning de vulnerabilidades"""
        from modules.vulnerabilities import VulnerabilityScanner
        
        scanner = VulnerabilityScanner(self.tm)
        
        # Parsear opÃ§Ãµes do Nuclei
        tags = None
        if self.args.nuclei_tags:
            tags = self.args.nuclei_tags.split(',')
        
        severity = None
        if self.args.nuclei_severity:
            severity = self.args.nuclei_severity.split(',')
        
        return scanner.scan(self.results['target'], tags=tags, severity=severity)
    
    def _run_wordpress(self) -> Dict[str, Any]:
        """MÃ³dulo de WordPress scanning"""
        from modules.wordpress import WordPressScanner
        
        scanner = WordPressScanner(self.tm)
        return scanner.scan(self.results['target'])
    
    def _run_xss(self) -> Dict[str, Any]:
        """MÃ³dulo de XSS testing"""
        from modules.xss import XSSScanner
        
        scanner = XSSScanner(self.tm)
        
        # Precisa de URLs com parÃ¢metros
        # Se temos crawl results, usar essas URLs
        urls = []
        if 'crawl' in self.results['modules']:
            urls = self.results['modules']['crawl'].get('urls', [])
        
        if not urls:
            urls = [self.results['target']]
        
        return scanner.scan(urls)
    
    def _run_sqli(self) -> Dict[str, Any]:
        """MÃ³dulo de SQL injection testing"""
        from modules.sqli import SQLiScanner
        
        scanner = SQLiScanner(self.tm)
        
        # OpÃ§Ãµes do SQLMap
        options = {
            'level': 1,
            'risk': 1,
            'threads': self.args.threads
        }
        
        return scanner.scan(self.results['target'], options=options)
    
    def _run_params(self) -> Dict[str, Any]:
        """MÃ³dulo de parameter discovery"""
        from modules.parameters import ParameterScanner
        
        scanner = ParameterScanner(self.tm)
        return scanner.scan(self.results['target'])
    
    def _generate_report(self):
        """Gera relatÃ³rios"""
        try:
            # JSON sempre
            self.reporter.generate_json(self.results)
            print(f"  {Colors.success('JSON report gerado')}")
            
            # HTML se solicitado
            if self.args.format in ['html', 'all']:
                self.reporter.generate_html(self.results)
                print(f"  {Colors.success('HTML report gerado')}")
            
            # PDF se solicitado
            if self.args.format in ['pdf', 'all']:
                try:
                    self.reporter.generate_pdf(self.results)
                    print(f"  {Colors.success('PDF report gerado')}")
                except Exception as e:
                    print(f"  {Colors.warning(f'PDF report falhou: {e}')}")
        
        except Exception as e:
            print(f"  {Colors.error(f'Erro ao gerar relatÃ³rio: {e}')}")
    
    def _print_summary(self):
        """Imprime resumo final"""
        print_section("âœ… SCAN COMPLETO")
        
        duration = self.results.get('duration', 0)
        print(f"DuraÃ§Ã£o: {Colors.CYAN}{duration:.2f}s{Colors.RESET}")
        print(f"MÃ³dulos executados: {Colors.CYAN}{len(self.results['modules'])}{Colors.RESET}")
        print(f"\nRelatÃ³rios salvos em: {Colors.GREEN}{self.output_dir}{Colors.RESET}\n")
        
        # EstatÃ­sticas por mÃ³dulo
        for module_name, module_results in self.results['modules'].items():
            if isinstance(module_results, dict) and 'error' not in module_results:
                # Contar itens encontrados
                count = 0
                if 'subdomains' in module_results:
                    count = len(module_results['subdomains'])
                elif 'urls' in module_results:
                    count = len(module_results['urls'])
                elif 'ports' in module_results:
                    count = len(module_results['ports'])
                elif 'vulnerabilities' in module_results:
                    count = sum(len(v) for v in module_results['vulnerabilities'].values())
                
                if count > 0:
                    print(f"  â€¢ {module_name}: {Colors.GREEN}{count} items{Colors.RESET}")

