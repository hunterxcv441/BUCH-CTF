"""
Engine principal de scanning que orquestra os m√≥dulos.
"""

import time
from typing import Dict, Any, List
from pathlib import Path
from datetime import datetime

from core.tool_manager import ToolManager
from core.colors import Colors, print_section
from core.utils import ensure_directory, get_timestamp, extract_domain
from core.reporter import Reporter
from core.progress import ProgressDisplay


class PentestScanner:
    """Engine principal que orquestra o pentest"""
    
    def __init__(self, tool_manager: ToolManager, args):
        self.tm = tool_manager
        self.args = args
        
        # Determinar target
        target = args.url or args.domain or args.list or 'unknown'
        if args.list:
            # Se for arquivo, usar primeiro target ou nome do arquivo
            from core.utils import read_lines
            try:
                targets = read_lines(args.list)
                target = targets[0] if targets else args.list
            except:
                target = args.list
        
        self.results = {
            'target': target,
            'start_time': datetime.now().isoformat(),
            'end_time': None,
            'duration': None,
            'modules': {}
        }
        
        # Configurar output
        if args.output:
            self.output_dir = Path(args.output)
        else:
            timestamp = get_timestamp()
            target_name = extract_domain(self.results['target'])
            self.output_dir = Path('output') / f"{target_name}_{timestamp}"
        
        ensure_directory(self.output_dir)
        
        self.reporter = Reporter(self.output_dir)
        self.progress = ProgressDisplay(silent=args.silent)
    
    def run(self):
        """Executa o scan completo"""
        start_time = time.time()
        
        print_section("üéØ INICIANDO PENTEST")
        print(f"Target: {Colors.CYAN}{self.results['target']}{Colors.RESET}")
        print(f"Output: {Colors.CYAN}{self.output_dir}{Colors.RESET}\n")
        
        # Determinar quais m√≥dulos executar
        modules_to_run = self._determine_modules()
        
        # Mostrar resumo dos m√≥dulos que ser√£o executados
        if not self.args.silent:
            self.progress.print_summary_box(
                "üìã M√≥dulos a Executar",
                {
                    "Total": len(modules_to_run),
                    "M√≥dulos": ", ".join([m[0] for m in modules_to_run])
                }
            )
        
        try:
            # Executar m√≥dulos
            for idx, (module_name, module_func) in enumerate(modules_to_run, 1):
                try:
                    self.progress.start_module(f"{module_name} ({idx}/{len(modules_to_run)})")
                    result = module_func()
                    self.results['modules'][module_name] = result
                    self.progress.end_module(success=True)
                    
                    # Mostrar resumo r√°pido dos resultados
                    self._show_module_summary(module_name, result)
                    
                except Exception as e:
                    self.progress.end_module(success=False)
                    print(f"{Colors.error(f'Erro no m√≥dulo {module_name}: {e}')}")
                    if self.args.verbose:
                        import traceback
                        traceback.print_exc()
                    self.results['modules'][module_name] = {'error': str(e)}
            
            # Finalizar
            end_time = time.time()
            self.results['end_time'] = datetime.now().isoformat()
            self.results['duration'] = end_time - start_time
            
            # Gerar relat√≥rio
            print_section("üìä GERANDO RELAT√ìRIO")
            self._generate_report()
            
            # Resumo final
            self._print_summary()
            
        except KeyboardInterrupt:
            print(f"\n\n{Colors.warning('Scan interrompido pelo usu√°rio')}")
            raise
    
    def _determine_modules(self) -> List[tuple]:
        """Determina quais m√≥dulos executar baseado nos args"""
        modules = []
        
        if self.args.full:
            # Scan completo - todos os m√≥dulos
            modules = [
                ('recon', self._run_recon),
                ('subdomain', self._run_subdomain),
                ('ports', self._run_ports),
                ('crawl', self._run_crawl),
                ('fuzz', self._run_fuzz),
                ('vulnerabilities', self._run_vulnerabilities),
            ]
        else:
            # M√≥dulos espec√≠ficos
            if self.args.recon:
                modules.append(('recon', self._run_recon))
            
            if self.args.subdomains:
                modules.append(('subdomain', self._run_subdomain))
            
            if self.args.ports:
                modules.append(('ports', self._run_ports))
            
            if self.args.crawl:
                modules.append(('crawl', self._run_crawl))
            
            if self.args.fuzz:
                modules.append(('fuzz', self._run_fuzz))
            
            if self.args.vuln:
                modules.append(('vulnerabilities', self._run_vulnerabilities))
            
            if self.args.wordpress:
                modules.append(('wordpress', self._run_wordpress))
            
            if self.args.xss:
                modules.append(('xss', self._run_xss))
            
            if self.args.sqli:
                modules.append(('sqli', self._run_sqli))
            
            if self.args.params:
                modules.append(('parameters', self._run_params))
        
        # Se nenhum m√≥dulo especificado, fazer recon b√°sico
        if not modules:
            modules.append(('recon', self._run_recon))
        
        return modules
    
    def _run_recon(self) -> Dict[str, Any]:
        """M√≥dulo de reconhecimento"""
        from modules.recon import ReconScanner
        
        scanner = ReconScanner(self.tm, progress=self.progress)
        return scanner.scan(self.results['target'])
    
    def _run_subdomain(self) -> Dict[str, Any]:
        """M√≥dulo de enumera√ß√£o de subdom√≠nios"""
        from modules.subdomain import SubdomainScanner
        
        domain = extract_domain(self.results['target'])
        scanner = SubdomainScanner(self.tm, progress=self.progress)
        return scanner.scan(domain)
    
    def _run_ports(self) -> Dict[str, Any]:
        """M√≥dulo de port scanning"""
        from modules.ports import PortScanner
        
        target = extract_domain(self.results['target'])
        scanner = PortScanner(self.tm, progress=self.progress)
        return scanner.scan(target, fast=not self.args.full)
    
    def _run_crawl(self) -> Dict[str, Any]:
        """M√≥dulo de web crawling"""
        from modules.crawler import WebCrawler
        
        scanner = WebCrawler(self.tm)
        return scanner.scan(self.results['target'])
    
    def _run_fuzz(self) -> Dict[str, Any]:
        """M√≥dulo de fuzzing"""
        from modules.fuzzer import DirectoryFuzzer
        
        scanner = DirectoryFuzzer(self.tm, progress=self.progress)
        wordlist = self.args.wordlist
        return scanner.scan(self.results['target'], wordlist=wordlist)
    
    def _run_vulnerabilities(self) -> Dict[str, Any]:
        """M√≥dulo de scanning de vulnerabilidades"""
        from modules.vulnerabilities import VulnerabilityScanner
        
        scanner = VulnerabilityScanner(self.tm, progress=self.progress)
        
        # Parsear op√ß√µes do Nuclei
        tags = None
        if self.args.nuclei_tags:
            tags = self.args.nuclei_tags.split(',')
        
        severity = None
        if self.args.nuclei_severity:
            severity = self.args.nuclei_severity.split(',')
        
        return scanner.scan(self.results['target'], tags=tags, severity=severity)
    
    def _run_wordpress(self) -> Dict[str, Any]:
        """M√≥dulo de WordPress scanning"""
        from modules.wordpress import WordPressScanner
        
        scanner = WordPressScanner(self.tm)
        return scanner.scan(self.results['target'])
    
    def _run_xss(self) -> Dict[str, Any]:
        """M√≥dulo de XSS testing"""
        from modules.xss import XSSScanner
        
        scanner = XSSScanner(self.tm)
        
        # Precisa de URLs com par√¢metros
        # Se temos crawl results, usar essas URLs
        urls = []
        if 'crawl' in self.results['modules']:
            urls = self.results['modules']['crawl'].get('urls', [])
        
        if not urls:
            urls = [self.results['target']]
        
        return scanner.scan(urls)
    
    def _run_sqli(self) -> Dict[str, Any]:
        """M√≥dulo de SQL injection testing"""
        from modules.sqli import SQLiScanner
        
        scanner = SQLiScanner(self.tm)
        
        # Op√ß√µes do SQLMap
        options = {
            'level': 1,
            'risk': 1,
            'threads': self.args.threads
        }
        
        return scanner.scan(self.results['target'], options=options)
    
    def _run_params(self) -> Dict[str, Any]:
        """M√≥dulo de parameter discovery"""
        from modules.parameters import ParameterScanner
        
        scanner = ParameterScanner(self.tm)
        return scanner.scan(self.results['target'])
    
    def _generate_report(self):
        """Gera relat√≥rios"""
        try:
            # JSON sempre
            self.reporter.generate_json(self.results)
            print(f"  {Colors.success('JSON report gerado')}")
            
            # HTML se solicitado
            if self.args.format in ['html', 'all']:
                self.reporter.generate_html(self.results)
                print(f"  {Colors.success('HTML report gerado')}")
            
            # PDF se solicitado
            if self.args.format in ['pdf', 'all']:
                try:
                    self.reporter.generate_pdf(self.results)
                    print(f"  {Colors.success('PDF report gerado')}")
                except Exception as e:
                    print(f"  {Colors.warning(f'PDF report falhou: {e}')}")
        
        except Exception as e:
            print(f"  {Colors.error(f'Erro ao gerar relat√≥rio: {e}')}")
    
    def _show_module_summary(self, module_name: str, result: Dict[str, Any]):
        """Mostra resumo r√°pido dos resultados de um m√≥dulo"""
        if self.args.silent or not isinstance(result, dict):
            return
        
        stats = {}
        
        # Contar diferentes tipos de resultados
        if 'subdomains' in result:
            stats['Subdom√≠nios'] = len(result.get('subdomains', []))
            stats['Ativos'] = len(result.get('active', []))
        
        if 'urls' in result:
            stats['URLs'] = len(result.get('urls', []))
            stats['Com Par√¢metros'] = len(result.get('parameters', []))
            stats['JS Files'] = len(result.get('js_files', []))
        
        if 'ports' in result:
            stats['Portas Abertas'] = len(result.get('ports', []))
        
        if 'vulnerabilities' in result:
            vulns = result['vulnerabilities']
            stats['Cr√≠ticas'] = len(vulns.get('critical', []))
            stats['Altas'] = len(vulns.get('high', []))
            stats['M√©dias'] = len(vulns.get('medium', []))
            stats['Baixas'] = len(vulns.get('low', []))
        
        if 'directories' in result:
            stats['Diret√≥rios'] = len(result.get('directories', []))
            stats['Arquivos'] = len(result.get('files', []))
            stats['Interessantes'] = len(result.get('interesting', []))
        
        if stats:
            self.progress.print_stats(stats, f"Resultados - {module_name}")
    
    def _print_summary(self):
        """Imprime resumo final"""
        print_section("‚úÖ SCAN COMPLETO")
        
        duration = self.results.get('duration', 0)
        
        # Estat√≠sticas gerais
        total_stats = {
            "Dura√ß√£o": f"{duration:.2f}s",
            "M√≥dulos Executados": len(self.results['modules']),
            "Relat√≥rios": self.output_dir
        }
        
        # Contar achados por tipo
        findings = {}
        for module_name, module_results in self.results['modules'].items():
            if isinstance(module_results, dict) and 'error' not in module_results:
                if 'subdomains' in module_results:
                    findings['Subdom√≠nios'] = findings.get('Subdom√≠nios', 0) + len(module_results['subdomains'])
                if 'urls' in module_results:
                    findings['URLs'] = findings.get('URLs', 0) + len(module_results['urls'])
                if 'ports' in module_results:
                    findings['Portas'] = findings.get('Portas', 0) + len(module_results['ports'])
                if 'vulnerabilities' in module_results:
                    vulns = module_results['vulnerabilities']
                    findings['Vulns Cr√≠ticas'] = findings.get('Vulns Cr√≠ticas', 0) + len(vulns.get('critical', []))
                    findings['Vulns Altas'] = findings.get('Vulns Altas', 0) + len(vulns.get('high', []))
        
        if findings:
            total_stats.update(findings)
        
        self.progress.print_summary_box("üìä Resumo Final", total_stats)
        
        print(f"Relat√≥rios salvos em: {Colors.GREEN}{self.output_dir}{Colors.RESET}\n")

